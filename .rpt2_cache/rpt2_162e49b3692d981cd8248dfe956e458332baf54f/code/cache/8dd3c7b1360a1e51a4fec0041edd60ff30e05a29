{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { hexToU8a, isHex, isObject, isU8a, isUndefined, u8aConcat, u8aToHex } from '@polkadot/util';\r\nimport { blake2AsU8a } from '@polkadot/util-crypto';\r\nimport U8a from './U8a';\r\nimport { compareMap, decodeU8a, mapToTypeMap } from './utils';\r\n/**\r\n * @name Struct\r\n * @description\r\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\r\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\r\n * values in the constructor and it manages the decoding. It is important that the constructor\r\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\r\n * it needs to decoded in the specific defined order.\r\n * @noInheritDoc\r\n */\r\nexport default class Struct extends Map {\r\n    constructor(Types, value = {}, jsonMap = new Map()) {\r\n        const Clazzes = mapToTypeMap(Types);\r\n        const decoded = Struct.decodeStruct(Clazzes, value, jsonMap);\r\n        super(Object.entries(decoded));\r\n        this._jsonMap = jsonMap;\r\n        this._Types = Clazzes;\r\n    }\r\n    /**\r\n     * Decode input to pass into constructor.\r\n     *\r\n     * @param Types - Types definition.\r\n     * @param value - Value to decode, one of:\r\n     * - null\r\n     * - undefined\r\n     * - hex\r\n     * - Uint8Array\r\n     * - object with `{ key1: value1, key2: value2 }`, assuming `key1` and `key2`\r\n     * are also keys in `Types`\r\n     * - array with `[value1, value2]` assuming the array has the same length as\r\n     * `Object.keys(Types)`\r\n     * @param jsonMap\r\n     */\r\n    static decodeStruct(Types, value, jsonMap) {\r\n        // l.debug(() => ['Struct.decode', { Types, value }]);\r\n        if (isHex(value)) {\r\n            return Struct.decodeStruct(Types, hexToU8a(value), jsonMap);\r\n        }\r\n        else if (isU8a(value)) {\r\n            const values = decodeU8a(value, Object.values(Types));\r\n            // Transform array of values to {key: value} mapping\r\n            return Object.keys(Types).reduce((raw, key, index) => {\r\n                // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.\r\n                raw[key] = values[index];\r\n                return raw;\r\n            }, {});\r\n        }\r\n        else if (!value) {\r\n            return {};\r\n        }\r\n        // We assume from here that value is a JS object (Array, Map, Object)\r\n        return Struct.decodeStructFromObject(Types, value, jsonMap);\r\n    }\r\n    static decodeStructFromObject(Types, value, jsonMap) {\r\n        return Object.keys(Types).reduce((raw, key, index) => {\r\n            // The key in the JSON can be snake_case (or other cases), but in our\r\n            // Types, result or any other maps, it's camelCase\r\n            const jsonKey = (jsonMap.get(key) && !value[key]) ? jsonMap.get(key) : key;\r\n            try {\r\n                if (Array.isArray(value)) {\r\n                    // TS2322: Type 'Codec' is not assignable to type 'T[keyof S]'.\r\n                    raw[key] = value[index] instanceof Types[key]\r\n                        ? value[index]\r\n                        : new Types[key](value[index]);\r\n                }\r\n                else if (value instanceof Map) {\r\n                    const mapped = value.get(jsonKey);\r\n                    raw[key] = mapped instanceof Types[key]\r\n                        ? mapped\r\n                        : new Types[key](mapped);\r\n                }\r\n                else if (isObject(value)) {\r\n                    raw[key] = value[jsonKey] instanceof Types[key]\r\n                        ? value[jsonKey]\r\n                        : new Types[key](value[jsonKey]);\r\n                }\r\n                else {\r\n                    throw new Error(`Struct: cannot decode type ${Types[key].name} with value ${JSON.stringify(value)}`);\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw new Error(`Struct: failed on '${jsonKey}':: ${error.message}`);\r\n            }\r\n            return raw;\r\n        }, {});\r\n    }\r\n    static with(Types) {\r\n        return class extends Struct {\r\n            constructor(value, jsonMap) {\r\n                super(Types, value, jsonMap);\r\n                Object.keys(Types).forEach((key) => {\r\n                    // do not clobber existing properties on the object\r\n                    if (!isUndefined(this[key])) {\r\n                        return;\r\n                    }\r\n                    Object.defineProperty(this, key, {\r\n                        enumerable: true,\r\n                        get: () => this.get(key)\r\n                    });\r\n                });\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @description Checks if the value is an empty value\r\n     */\r\n    get isEmpty() {\r\n        const items = this.toArray();\r\n        for (let i = 0; i < items.length; i++) {\r\n            if (!items[i].isEmpty) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @description Returns the Type description to sthe structure\r\n     */\r\n    get Type() {\r\n        return Object\r\n            .entries(this._Types)\r\n            .reduce((result, [key, Type]) => {\r\n            result[key] = Type.name;\r\n            return result;\r\n        }, {});\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        return this.toArray().reduce((length, entry) => {\r\n            length += entry.encodedLength;\r\n            return length;\r\n        }, 0);\r\n    }\r\n    /**\r\n     * @description returns a hash of the contents\r\n     */\r\n    get hash() {\r\n        return new U8a(blake2AsU8a(this.toU8a(), 256));\r\n    }\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other) {\r\n        return compareMap(this, other);\r\n    }\r\n    /**\r\n     * @description Returns a specific names entry in the structure\r\n     * @param name The name of the entry to retrieve\r\n     */\r\n    get(name) {\r\n        return super.get(name);\r\n    }\r\n    /**\r\n     * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\r\n     */\r\n    getAtIndex(index) {\r\n        return this.toArray()[index];\r\n    }\r\n    /**\r\n     * @description Converts the Object to an standard JavaScript Array\r\n     */\r\n    toArray() {\r\n        return [...this.values()];\r\n    }\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex() {\r\n        return u8aToHex(this.toU8a());\r\n    }\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON() {\r\n        // FIXME the return type string is only used by Extrinsic (extends Struct),\r\n        // but its toJSON is the hex value\r\n        return [...this.keys()].reduce((json, key) => {\r\n            const jsonKey = this._jsonMap.get(key) || key;\r\n            const value = this.get(key);\r\n            json[jsonKey] = value && value.toJSON();\r\n            return json;\r\n        }, {});\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return JSON.stringify(Object.entries(this._Types).reduce((result, [key, Type]) => {\r\n            result[key] = new Type().toRawType();\r\n            return result;\r\n        }, {}));\r\n    }\r\n    /**\r\n     * @description Returns the string representation of the value\r\n     */\r\n    toString() {\r\n        return JSON.stringify(this.toJSON());\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        return u8aConcat(...this.toArray().map((entry) => entry.toU8a(isBare)));\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util-crypto/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/U8a.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/utils/index.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/codec/Struct.d.ts","writeByteOrderMark":false,"text":"import { AnyJsonObject, Codec, Constructor, ConstructorDef, IHash, InterfaceTypes } from '../types';\r\ndeclare type TypesDef<T = Codec> = Record<string, InterfaceTypes | Constructor<T>>;\r\n/**\r\n * @name Struct\r\n * @description\r\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\r\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\r\n * values in the constructor and it manages the decoding. It is important that the constructor\r\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\r\n * it needs to decoded in the specific defined order.\r\n * @noInheritDoc\r\n */\r\nexport default class Struct<S extends TypesDef = TypesDef, T extends {\r\n    [K in keyof S]: Codec;\r\n} = {\r\n    [K in keyof S]: Codec;\r\n}, V extends {\r\n    [K in keyof S]: any;\r\n} = {\r\n    [K in keyof S]: any;\r\n}, E extends {\r\n    [K in keyof S]: string;\r\n} = {\r\n    [K in keyof S]: string;\r\n}> extends Map<keyof S, Codec> implements Codec {\r\n    protected _jsonMap: Map<keyof S, string>;\r\n    protected _Types: ConstructorDef;\r\n    constructor(Types: S, value?: V | Map<any, any> | any[] | string, jsonMap?: Map<keyof S, string>);\r\n    /**\r\n     * Decode input to pass into constructor.\r\n     *\r\n     * @param Types - Types definition.\r\n     * @param value - Value to decode, one of:\r\n     * - null\r\n     * - undefined\r\n     * - hex\r\n     * - Uint8Array\r\n     * - object with `{ key1: value1, key2: value2 }`, assuming `key1` and `key2`\r\n     * are also keys in `Types`\r\n     * - array with `[value1, value2]` assuming the array has the same length as\r\n     * `Object.keys(Types)`\r\n     * @param jsonMap\r\n     */\r\n    private static decodeStruct;\r\n    private static decodeStructFromObject;\r\n    static with<S extends TypesDef>(Types: S): Constructor<Struct<S>>;\r\n    /**\r\n     * @description Checks if the value is an empty value\r\n     */\r\n    readonly isEmpty: boolean;\r\n    /**\r\n     * @description Returns the Type description to sthe structure\r\n     */\r\n    readonly Type: E;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description returns a hash of the contents\r\n     */\r\n    readonly hash: IHash;\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other?: any): boolean;\r\n    /**\r\n     * @description Returns a specific names entry in the structure\r\n     * @param name The name of the entry to retrieve\r\n     */\r\n    get(name: keyof S): Codec | undefined;\r\n    /**\r\n     * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\r\n     */\r\n    getAtIndex(index: number): Codec;\r\n    /**\r\n     * @description Converts the Object to an standard JavaScript Array\r\n     */\r\n    toArray(): Codec[];\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex(): string;\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON(): AnyJsonObject | string;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n    /**\r\n     * @description Returns the string representation of the value\r\n     */\r\n    toString(): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\nexport {};\r\n"}}
