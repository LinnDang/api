{"code":"// Copyright 2017-2019 @polkadot/api-metadata authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { Bytes, Compact, StorageKey, U8a } from '@polkadot/types';\r\nimport { createTypeUnsafe } from '@polkadot/types/codec/createType';\r\nimport { PlainType, StorageEntryMetadata, StorageEntryModifier, StorageEntryType } from '@polkadot/types/Metadata/v6/Storage';\r\nimport { assert, isNull, isUndefined, stringLowerFirst, stringToU8a, u8aConcat } from '@polkadot/util';\r\nimport getHasher from './getHasher';\r\n/**\r\n * From the schema of a function in the module's storage, generate the function\r\n * that will return the correct storage key.\r\n *\r\n * @param schema - The function's definition schema to create the function from.\r\n * The schema is taken from state_getMetadata.\r\n * @param options - Additional options when creating the function. These options\r\n * are not known at runtime (from state_getMetadata), they need to be supplied\r\n * by us manually at compile time.\r\n */\r\nexport default function createFunction({ meta, method, prefix, section }, options = {}) {\r\n    const stringKey = options.key\r\n        ? options.key\r\n        : `${prefix} ${method}`;\r\n    const rawKey = stringToU8a(stringKey);\r\n    // Get the hashing function\r\n    let hasher;\r\n    let key2Hasher;\r\n    if (meta.type.isDoubleMap) {\r\n        hasher = getHasher(meta.type.asDoubleMap.hasher);\r\n        key2Hasher = getHasher(meta.type.asDoubleMap.key2Hasher);\r\n    }\r\n    else if (meta.type.isMap) {\r\n        hasher = getHasher(meta.type.asMap.hasher);\r\n    }\r\n    else {\r\n        hasher = getHasher();\r\n    }\r\n    // Can only have zero or one argument:\r\n    //   - storage.balances.freeBalance(address)\r\n    //   - storage.timestamp.blockPeriod()\r\n    // For doublemap queries the params is passed in as an tuple, [key1, key2]\r\n    const _storageFn = (arg) => {\r\n        let key = rawKey;\r\n        if (meta.type.isDoubleMap) {\r\n            assert(Array.isArray(arg) && !isUndefined(arg[0]) && !isNull(arg[0]) && !isUndefined(arg[1]) && !isNull(arg[1]), `${meta.name} expects two arguments`);\r\n            // we have checked that it is an array in the assert, so all ok\r\n            const [key1, key2] = arg;\r\n            const type1 = meta.type.asDoubleMap.key1.toString();\r\n            const type2 = meta.type.asDoubleMap.key2.toString();\r\n            const param1Encoded = u8aConcat(key, createTypeUnsafe(type1, [key1]).toU8a(true));\r\n            const param1Hashed = hasher(param1Encoded);\r\n            const param2Hashed = key2Hasher(createTypeUnsafe(type2, [key2]).toU8a(true));\r\n            return Compact.addLengthPrefix(u8aConcat(param1Hashed, param2Hashed));\r\n        }\r\n        if (meta.type.isMap) {\r\n            assert(!isUndefined(arg) && !isNull(arg), `${meta.name} expects one argument`);\r\n            const type = meta.type.asMap.key.toString();\r\n            const param = createTypeUnsafe(type, [arg]).toU8a();\r\n            key = u8aConcat(key, param);\r\n        }\r\n        // StorageKey is a Bytes, so is length-prefixed\r\n        return Compact.addLengthPrefix(options.skipHashing\r\n            ? key\r\n            : hasher(key));\r\n    };\r\n    const storageFn = _storageFn;\r\n    storageFn.meta = meta;\r\n    storageFn.method = stringLowerFirst(method);\r\n    storageFn.prefix = prefix;\r\n    storageFn.section = section;\r\n    storageFn.toJSON = () => meta.toJSON();\r\n    if (meta.type.isMap && meta.type.asMap.isLinked) {\r\n        const headHash = new U8a(hasher(`head of ${stringKey}`));\r\n        const headFn = () => headHash;\r\n        // metadata with a fallback value using the type of the key, the normal\r\n        // meta fallback only applies to actual entry values, create one for head\r\n        headFn.meta = new StorageEntryMetadata({\r\n            name: meta.name,\r\n            modifier: new StorageEntryModifier('Required'),\r\n            type: new StorageEntryType(new PlainType(meta.type.asMap.key), 0),\r\n            fallback: new Bytes(createTypeUnsafe(meta.type.asMap.key.toString()).toHex()),\r\n            documentation: meta.documentation\r\n        });\r\n        // here we pass the section/method through as well - these are not on\r\n        // the function itself, so specify these explicitly to the constructor\r\n        storageFn.headKey = new StorageKey(headFn, {\r\n            method: storageFn.method,\r\n            section: `head of ${storageFn.section}`\r\n        });\r\n    }\r\n    return storageFn;\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/bn.js/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/createType.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/Metadata/v6/Storage.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/StorageKey.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api-metadata/src/storage/fromMetadata/getHasher.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/api-metadata/src/storage/fromMetadata/createFunction.d.ts","writeByteOrderMark":false,"text":"import { StorageEntryMetadata } from '@polkadot/types/Metadata/v6/Storage';\r\nimport { StorageEntry } from '@polkadot/types/primitive/StorageKey';\r\nexport interface CreateItemOptions {\r\n    key?: string;\r\n    skipHashing?: boolean;\r\n}\r\nexport interface CreateItemFn {\r\n    meta: StorageEntryMetadata;\r\n    method: string;\r\n    prefix: string;\r\n    section: string;\r\n}\r\n/**\r\n * From the schema of a function in the module's storage, generate the function\r\n * that will return the correct storage key.\r\n *\r\n * @param schema - The function's definition schema to create the function from.\r\n * The schema is taken from state_getMetadata.\r\n * @param options - Additional options when creating the function. These options\r\n * are not known at runtime (from state_getMetadata), they need to be supplied\r\n * by us manually at compile time.\r\n */\r\nexport default function createFunction({ meta, method, prefix, section }: CreateItemFn, options?: CreateItemOptions): StorageEntry;\r\n"}}
