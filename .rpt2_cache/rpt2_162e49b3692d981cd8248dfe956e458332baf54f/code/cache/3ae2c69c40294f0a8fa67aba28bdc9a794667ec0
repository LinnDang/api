{"code":"// Copyright 2017-2019 @polkadot/api authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport BN from 'bn.js';\r\nimport { combineLatest, of } from 'rxjs';\r\nimport { first, map, mergeMap, switchMap, tap } from 'rxjs/operators';\r\nimport { createType } from '@polkadot/types';\r\nimport { isBn, isFunction, isNumber, isUndefined } from '@polkadot/util';\r\nimport filterEvents from './util/filterEvents';\r\nimport SignerPayload from './SignerPayload';\r\n// The default for 6s allowing for 5min eras. When translating this to faster blocks -\r\n//   - 4s = (10 / 15) * 5 = 3.33m\r\n//   - 2s = (10 / 30) * 5 = 1.66m\r\nconst BLOCKTIME = 6;\r\nconst ONE_MINUTE = 60 / BLOCKTIME;\r\nconst DEFAULT_MORTAL_LENGTH = 5 * ONE_MINUTE;\r\nfunction isKeyringPair(account) {\r\n    return isFunction(account.sign);\r\n}\r\nexport class SubmittableResult {\r\n    constructor({ events, status }) {\r\n        this.events = events || [];\r\n        this.status = status;\r\n    }\r\n    get isCompleted() {\r\n        return this.isError || this.isFinalized;\r\n    }\r\n    get isError() {\r\n        return this.status.isDropped || this.status.isInvalid || this.status.isUsurped;\r\n    }\r\n    get isFinalized() {\r\n        return this.status.isFinalized;\r\n    }\r\n    /**\r\n     * @description Finds an EventRecord for the specified method & section\r\n     */\r\n    findRecord(section, method) {\r\n        return this.events.find(({ event }) => event.section === section && event.method === method);\r\n    }\r\n}\r\nexport default function createSubmittableExtrinsic(type, api, decorateMethod, extrinsic, trackingCb) {\r\n    const _extrinsic = createType('Extrinsic', extrinsic, { version: api.extrinsicType });\r\n    const _noStatusCb = type === 'rxjs';\r\n    function updateSigner(updateId, status) {\r\n        if ((updateId !== -1) && api.signer && api.signer.update) {\r\n            api.signer.update(updateId, status);\r\n        }\r\n    }\r\n    function statusObservable(status) {\r\n        if (!status.isFinalized) {\r\n            const result = new SubmittableResult({ status });\r\n            trackingCb && trackingCb(result);\r\n            return of(result);\r\n        }\r\n        const blockHash = status.asFinalized;\r\n        return combineLatest([\r\n            api.rpc.chain.getBlock(blockHash),\r\n            api.query.system.events.at(blockHash)\r\n        ]).pipe(map(([signedBlock, allEvents]) => {\r\n            const result = new SubmittableResult({\r\n                events: filterEvents(_extrinsic.hash, signedBlock, allEvents),\r\n                status\r\n            });\r\n            trackingCb && trackingCb(result);\r\n            return result;\r\n        }));\r\n    }\r\n    function sendObservable(updateId = -1) {\r\n        return api.rpc.author\r\n            .submitExtrinsic(_extrinsic)\r\n            .pipe(tap((hash) => {\r\n            updateSigner(updateId, hash);\r\n        }));\r\n    }\r\n    function subscribeObservable(updateId = -1) {\r\n        return api.rpc.author\r\n            .submitAndWatchExtrinsic(_extrinsic)\r\n            .pipe(switchMap((status) => statusObservable(status)), tap((status) => {\r\n            updateSigner(updateId, status);\r\n        }));\r\n    }\r\n    function expandOptions(options, extras) {\r\n        return {\r\n            blockHash: api.genesisHash,\r\n            version: api.runtimeVersion,\r\n            ...options,\r\n            ...extras,\r\n            genesisHash: api.genesisHash\r\n        };\r\n    }\r\n    function expandEraOptions(options, { header, nonce }) {\r\n        if (!header) {\r\n            if (isNumber(options.era)) {\r\n                // since we have no header, it is immortal, remove any option overrides\r\n                // so we only supply the genesisHash and no era to the construction\r\n                delete options.era;\r\n                delete options.blockHash;\r\n            }\r\n            return expandOptions(options, { nonce });\r\n        }\r\n        return expandOptions(options, {\r\n            blockHash: header.hash,\r\n            era: createType('ExtrinsicEra', {\r\n                current: header.number,\r\n                period: options.era || DEFAULT_MORTAL_LENGTH\r\n            }),\r\n            nonce\r\n        });\r\n    }\r\n    const signOrigin = _extrinsic.sign;\r\n    Object.defineProperties(_extrinsic, {\r\n        send: {\r\n            value: function (statusCb) {\r\n                const isSubscription = _noStatusCb || !!statusCb;\r\n                return decorateMethod(isSubscription ? subscribeObservable : sendObservable)(statusCb);\r\n            }\r\n        },\r\n        sign: {\r\n            value: function (account, optionOrNonce) {\r\n                // HACK here we actually override nonce if it was specified (backwards compat for\r\n                // the previous signature - don't let userspace break, but allow then time to upgrade)\r\n                const options = isBn(optionOrNonce) || isNumber(optionOrNonce)\r\n                    ? { nonce: optionOrNonce }\r\n                    : optionOrNonce;\r\n                signOrigin.apply(_extrinsic, [account, expandOptions(options, {})]);\r\n                return this;\r\n            }\r\n        },\r\n        signAndSend: {\r\n            value: function (account, optionsOrStatus, statusCb) {\r\n                let options = {};\r\n                if (isFunction(optionsOrStatus)) {\r\n                    statusCb = optionsOrStatus;\r\n                }\r\n                else {\r\n                    options = { ...optionsOrStatus };\r\n                }\r\n                const isSubscription = _noStatusCb || !!statusCb;\r\n                const address = isKeyringPair(account) ? account.address : account.toString();\r\n                let updateId;\r\n                return decorateMethod(() => (combineLatest([\r\n                    // if we have a nonce already, don't retrieve the latest, use what is there\r\n                    isUndefined(options.nonce)\r\n                        ? api.query.system.accountNonce(address)\r\n                        : of(createType('Index', options.nonce)),\r\n                    // if we have an era provided already or eraLength is <= 0 (immortal)\r\n                    // don't get the latest block, just pass null, handle in mergeMap\r\n                    (isUndefined(options.era) || (isNumber(options.era) && options.era > 0))\r\n                        ? api.rpc.chain.getHeader()\r\n                        : of(null)\r\n                ])).pipe(first(), mergeMap(async ([nonce, header]) => {\r\n                    const eraOptions = expandEraOptions(options, { header, nonce });\r\n                    // FIXME This is becoming real messy with all the options - way past\r\n                    // \"a method should fit on a single screen\" stage. (Probably want to\r\n                    // clean this when we remove `api.signer.sign` in the next beta cycle)\r\n                    if (isKeyringPair(account)) {\r\n                        this.sign(account, eraOptions);\r\n                    }\r\n                    else if (api.signer) {\r\n                        const payload = new SignerPayload({\r\n                            ...eraOptions,\r\n                            address,\r\n                            method: _extrinsic.method,\r\n                            blockNumber: header ? header.number : 0,\r\n                            genesisHash: api.genesisHash,\r\n                            version: api.extrinsicType\r\n                        });\r\n                        if (api.signer.signPayload) {\r\n                            const { id, signature } = await api.signer.signPayload(payload.toPayload());\r\n                            // Here we explicitly call `toPayload()` again instead of working with an object\r\n                            // (reference) as passed to the signer. This means that we are sure that the\r\n                            // payload data is not modified from our inputs, but the signer\r\n                            _extrinsic.addSignature(address, signature, payload.toPayload());\r\n                            updateId = id;\r\n                        }\r\n                        else if (api.signer.signRaw) {\r\n                            const { id, signature } = await api.signer.signRaw(payload.toRaw());\r\n                            // as above, always trust our payload as the signle sourec of truth\r\n                            _extrinsic.addSignature(address, signature, payload.toPayload());\r\n                            updateId = id;\r\n                        }\r\n                        else if (api.signer.sign) {\r\n                            console.warn('The Signer.sign interface is deprecated and will be removed in a future version, Swap to using the Signer.signPayload interface instead.');\r\n                            updateId = await api.signer.sign(_extrinsic, address, {\r\n                                ...eraOptions,\r\n                                blockNumber: header ? header.number.toBn() : new BN(0),\r\n                                genesisHash: api.genesisHash\r\n                            });\r\n                        }\r\n                        else {\r\n                            throw new Error('Invalid signer interface');\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error('no signer exists');\r\n                    }\r\n                }), switchMap(() => {\r\n                    return isSubscription\r\n                        ? subscribeObservable(updateId)\r\n                        : sendObservable(updateId);\r\n                })))(statusCb);\r\n            }\r\n        }\r\n    });\r\n    return _extrinsic;\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/bn.js/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/operators/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/index.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/util/filterEvents.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/Base.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/SignerPayload.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/api/src/SubmittableExtrinsic.d.ts","writeByteOrderMark":false,"text":"import { AccountId, Address, Call, ExtrinsicStatus, EventRecord, Hash } from '@polkadot/types/interfaces';\r\nimport { AnyNumber, AnyU8a, Callback, IExtrinsic, IExtrinsicEra, IKeyringPair, SignatureOptions } from '@polkadot/types/types';\r\nimport { ApiInterfaceRx, ApiTypes } from './types';\r\nimport { Observable } from 'rxjs';\r\nimport ApiBase from './Base';\r\nexport interface ISubmittableResult {\r\n    readonly events: EventRecord[];\r\n    readonly status: ExtrinsicStatus;\r\n    readonly isCompleted: boolean;\r\n    readonly isError: boolean;\r\n    readonly isFinalized: boolean;\r\n    findRecord(section: string, method: string): EventRecord | undefined;\r\n}\r\nexport declare type SumbitableResultResult<ApiType> = ApiType extends 'rxjs' ? Observable<ISubmittableResult> : Promise<Hash>;\r\nexport declare type SumbitableResultSubscription<ApiType> = ApiType extends 'rxjs' ? Observable<ISubmittableResult> : Promise<() => void>;\r\ninterface SubmittableResultValue {\r\n    events?: EventRecord[];\r\n    status: ExtrinsicStatus;\r\n}\r\ninterface SignerOptions {\r\n    blockHash: AnyU8a;\r\n    era?: IExtrinsicEra | number;\r\n    nonce: AnyNumber;\r\n    tip?: AnyNumber;\r\n}\r\nexport declare class SubmittableResult implements ISubmittableResult {\r\n    readonly events: EventRecord[];\r\n    readonly status: ExtrinsicStatus;\r\n    constructor({ events, status }: SubmittableResultValue);\r\n    readonly isCompleted: boolean;\r\n    readonly isError: boolean;\r\n    readonly isFinalized: boolean;\r\n    /**\r\n     * @description Finds an EventRecord for the specified method & section\r\n     */\r\n    findRecord(section: string, method: string): EventRecord | undefined;\r\n}\r\nexport interface SubmittableExtrinsic<ApiType> extends IExtrinsic {\r\n    send(): SumbitableResultResult<ApiType>;\r\n    send(statusCb: Callback<ISubmittableResult>): SumbitableResultSubscription<ApiType>;\r\n    sign(account: IKeyringPair, _options: Partial<SignatureOptions>): this;\r\n    signAndSend(account: IKeyringPair | string | AccountId | Address, options?: Partial<SignerOptions>): SumbitableResultResult<ApiType>;\r\n    signAndSend(account: IKeyringPair | string | AccountId | Address, statusCb: Callback<ISubmittableResult>): SumbitableResultSubscription<ApiType>;\r\n    signAndSend(account: IKeyringPair | string | AccountId | Address, options: Partial<SignerOptions>, statusCb?: Callback<ISubmittableResult>): SumbitableResultSubscription<ApiType>;\r\n}\r\nexport default function createSubmittableExtrinsic<ApiType>(type: ApiTypes, api: ApiInterfaceRx, decorateMethod: ApiBase<ApiType>['decorateMethod'], extrinsic: Call | Uint8Array | string, trackingCb?: Callback<ISubmittableResult>): SubmittableExtrinsic<ApiType>;\r\nexport {};\r\n"}}
