{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { assert, bnToBn, hexToU8a, isHex, isU8a, isObject, u8aToBn } from '@polkadot/util';\r\nimport Enum from '../../codec/Enum';\r\nimport Tuple from '../../codec/Tuple';\r\nimport U8a from '../../codec/U8a';\r\nimport U64 from '../U64';\r\nimport { IMMORTAL_ERA } from './constants';\r\n/**\r\n * @name ImmortalEra\r\n * @description\r\n * The ImmortalEra for an extrinsic\r\n */\r\nexport class ImmortalEra extends U8a {\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    constructor(value) {\r\n        // For immortals, we always provide the known value (i.e. treated as a\r\n        // constant no matter how it is constructed - it is a fixed structure)\r\n        super(IMMORTAL_ERA);\r\n    }\r\n}\r\n/**\r\n * @name MortalEra\r\n * @description\r\n * The MortalEra for an extrinsic, indicating period and phase\r\n */\r\nexport class MortalEra extends Tuple {\r\n    constructor(value) {\r\n        super({\r\n            period: U64,\r\n            phase: U64\r\n        }, MortalEra.decodeMortalEra(value));\r\n    }\r\n    static decodeMortalEra(value) {\r\n        if (isHex(value)) {\r\n            return MortalEra.decodeMortalU8a(hexToU8a(value));\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            return MortalEra.decodeMortalU8a(new Uint8Array(value));\r\n        }\r\n        else if (isU8a(value)) {\r\n            return MortalEra.decodeMortalU8a(value);\r\n        }\r\n        else if (isObject(value)) {\r\n            const { current, period } = value;\r\n            let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\r\n            calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\r\n            const phase = current % calPeriod;\r\n            const quantizeFactor = Math.max(calPeriod >> 12, 1);\r\n            const quantizedPhase = phase / quantizeFactor * quantizeFactor;\r\n            return [new U64(calPeriod), new U64(quantizedPhase)];\r\n        }\r\n        else if (!value) {\r\n            return [new U64(), new U64()];\r\n        }\r\n        throw new Error('Invalid data passed to Mortal era');\r\n    }\r\n    static decodeMortalU8a(value) {\r\n        if (value.length === 0) {\r\n            return [new U64(), new U64()];\r\n        }\r\n        const first = u8aToBn(value.subarray(0, 1)).toNumber();\r\n        const second = u8aToBn(value.subarray(1, 2)).toNumber();\r\n        const encoded = first + (second << 8);\r\n        const period = 2 << (encoded % (1 << 4));\r\n        const quantizeFactor = Math.max(period >> 12, 1);\r\n        const phase = (encoded >> 4) * quantizeFactor;\r\n        assert(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\r\n        return [new U64(period), new U64(phase)];\r\n    }\r\n    /**\r\n     * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\r\n     */\r\n    get encodedLength() {\r\n        return 2;\r\n    }\r\n    /**\r\n     * @description The period of this Mortal wraps as a [[U64]]\r\n     */\r\n    get period() {\r\n        return this[0];\r\n    }\r\n    /**\r\n     * @description The phase of this Mortal wraps as a [[U64]]\r\n     */\r\n    get phase() {\r\n        return this[1];\r\n    }\r\n    /**\r\n     * @description Returns a JSON representation of the actual value\r\n     */\r\n    toJSON() {\r\n        return this.toHex();\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     * Period and phase are encoded:\r\n     *   - The period of validity from the block hash found in the signing material.\r\n     *   - The phase in the period that this transaction's lifetime begins (and, importantly,\r\n     *     implies which block hash is included in the signature material). If the `period` is\r\n     *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\r\n     *     `period` is.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    toU8a(isBare) {\r\n        const period = this.period.toNumber();\r\n        const phase = this.phase.toNumber();\r\n        const quantizeFactor = Math.max(period >> 12, 1);\r\n        const trailingZeros = this.getTrailingZeros(period);\r\n        const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (((phase / quantizeFactor) << 4));\r\n        const first = encoded >> 8;\r\n        const second = encoded & 0xff;\r\n        return new Uint8Array([second, first]);\r\n    }\r\n    /**\r\n     * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\r\n     */\r\n    birth(current) {\r\n        // FIXME No toNumber() here\r\n        return Math.floor((Math.max(bnToBn(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\r\n    }\r\n    /**\r\n     * @description Get the block number of the first block at which the era has ended.\r\n     */\r\n    death(current) {\r\n        // FIXME No toNumber() here\r\n        return this.birth(current) + this.period.toNumber();\r\n    }\r\n    /**\r\n     * @description convert the number to binary and get the trailing zero's.\r\n     */\r\n    getTrailingZeros(period) {\r\n        const binary = period.toString(2);\r\n        let index = 0;\r\n        while (binary[binary.length - 1 - index] === '0') {\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n}\r\n/**\r\n * @name ExtrinsicEra\r\n * @description\r\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\r\n */\r\nexport default class ExtrinsicEra extends Enum {\r\n    constructor(value) {\r\n        super({\r\n            ImmortalEra,\r\n            MortalEra\r\n        }, ExtrinsicEra.decodeExtrinsicEra(value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/ban-types\r\n    static decodeExtrinsicEra(value = new Uint8Array()) {\r\n        if (!value) {\r\n            return new Uint8Array([0]);\r\n        }\r\n        else if (value instanceof ExtrinsicEra) {\r\n            return ExtrinsicEra.decodeExtrinsicEra(value.toU8a());\r\n        }\r\n        else if (isHex(value)) {\r\n            return ExtrinsicEra.decodeExtrinsicEra(hexToU8a(value));\r\n        }\r\n        else if (isU8a(value)) {\r\n            return (!value.length || value[0] === 0)\r\n                ? new Uint8Array([0])\r\n                : new Uint8Array([1, value[0], value[1]]);\r\n        }\r\n        else if (isObject(value)) {\r\n            // this is to de-serialize from JSON\r\n            if (value.MortalEra) {\r\n                return { MortalEra: value.MortalEra };\r\n            }\r\n            else if (value.ImmortalEra) {\r\n                return { ImmortalEra: value.ImmortalEra };\r\n            }\r\n            return { MortalEra: value };\r\n        }\r\n        throw new Error('Invalid data passed to Era');\r\n    }\r\n    /**\r\n     * @description Overide the encoded length method\r\n     */\r\n    get encodedLength() {\r\n        if (this.index === 0) {\r\n            return this.asImmortalEra.encodedLength;\r\n        }\r\n        else {\r\n            return this.asMortalEra.encodedLength;\r\n        }\r\n    }\r\n    /**\r\n     * @description Returns the item as a [[ImmortalEra]]\r\n     */\r\n    get asImmortalEra() {\r\n        assert(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);\r\n        return this.value;\r\n    }\r\n    /**\r\n     * @description Returns the item as a [[MortalEra]]\r\n     */\r\n    get asMortalEra() {\r\n        assert(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);\r\n        return this.value;\r\n    }\r\n    /**\r\n     * @description `true` if Immortal\r\n     */\r\n    get isImmortalEra() {\r\n        return this.index === 0;\r\n    }\r\n    /**\r\n     * @description `true` if Mortal\r\n     */\r\n    get isMortalEra() {\r\n        return this.index > 0;\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        return this.isMortalEra\r\n            ? this.asMortalEra.toU8a(isBare)\r\n            : this.asImmortalEra.toU8a(isBare);\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/bn.js/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Enum.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Tuple.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/U8a.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/U64.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/constants.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Extrinsic/ExtrinsicEra.d.ts","writeByteOrderMark":false,"text":"import { AnyU8a, IExtrinsicEra } from '../../types';\r\nimport BN from 'bn.js';\r\nimport Enum from '../../codec/Enum';\r\nimport Tuple from '../../codec/Tuple';\r\nimport U8a from '../../codec/U8a';\r\nimport U64 from '../U64';\r\ninterface MortalMethod {\r\n    current: number;\r\n    period: number;\r\n}\r\n/**\r\n * @name ImmortalEra\r\n * @description\r\n * The ImmortalEra for an extrinsic\r\n */\r\nexport declare class ImmortalEra extends U8a {\r\n    constructor(value?: AnyU8a);\r\n}\r\n/**\r\n * @name MortalEra\r\n * @description\r\n * The MortalEra for an extrinsic, indicating period and phase\r\n */\r\nexport declare class MortalEra extends Tuple {\r\n    constructor(value?: MortalMethod | Uint8Array | number[] | string);\r\n    private static decodeMortalEra;\r\n    private static decodeMortalU8a;\r\n    /**\r\n     * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description The period of this Mortal wraps as a [[U64]]\r\n     */\r\n    readonly period: U64;\r\n    /**\r\n     * @description The phase of this Mortal wraps as a [[U64]]\r\n     */\r\n    readonly phase: U64;\r\n    /**\r\n     * @description Returns a JSON representation of the actual value\r\n     */\r\n    toJSON(): any;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     * Period and phase are encoded:\r\n     *   - The period of validity from the block hash found in the signing material.\r\n     *   - The phase in the period that this transaction's lifetime begins (and, importantly,\r\n     *     implies which block hash is included in the signature material). If the `period` is\r\n     *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\r\n     *     `period` is.\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n    /**\r\n     * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\r\n     */\r\n    birth(current: BN | number): number;\r\n    /**\r\n     * @description Get the block number of the first block at which the era has ended.\r\n     */\r\n    death(current: BN | number): number;\r\n    /**\r\n     * @description convert the number to binary and get the trailing zero's.\r\n     */\r\n    private getTrailingZeros;\r\n}\r\n/**\r\n * @name ExtrinsicEra\r\n * @description\r\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\r\n */\r\nexport default class ExtrinsicEra extends Enum implements IExtrinsicEra {\r\n    constructor(value?: any);\r\n    private static decodeExtrinsicEra;\r\n    /**\r\n     * @description Overide the encoded length method\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description Returns the item as a [[ImmortalEra]]\r\n     */\r\n    readonly asImmortalEra: ImmortalEra;\r\n    /**\r\n     * @description Returns the item as a [[MortalEra]]\r\n     */\r\n    readonly asMortalEra: MortalEra;\r\n    /**\r\n     * @description `true` if Immortal\r\n     */\r\n    readonly isImmortalEra: boolean;\r\n    /**\r\n     * @description `true` if Mortal\r\n     */\r\n    readonly isMortalEra: boolean;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the parity-codec specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\nexport {};\r\n"}}
