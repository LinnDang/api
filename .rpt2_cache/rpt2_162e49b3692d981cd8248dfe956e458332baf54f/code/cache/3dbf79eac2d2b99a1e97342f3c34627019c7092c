{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { u8aToU8a, assert } from '@polkadot/util';\r\nimport Compact from './Compact';\r\nimport { decodeU8a, typeToConstructor } from './utils';\r\nimport AbstractArray from './AbstractArray';\r\nconst MAX_LENGTH = 32768;\r\n/**\r\n * @name Vec\r\n * @description\r\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\r\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\r\n * specific encoding/decoding on top of the base type.\r\n */\r\nexport default class Vec extends AbstractArray {\r\n    constructor(Type, value = []) {\r\n        const Clazz = typeToConstructor(Type);\r\n        super(...Vec.decodeVec(Clazz, value));\r\n        this._Type = Clazz;\r\n    }\r\n    static decodeVec(Type, value) {\r\n        if (Array.isArray(value)) {\r\n            return value.map((entry, index) => {\r\n                try {\r\n                    return entry instanceof Type\r\n                        ? entry\r\n                        : new Type(entry);\r\n                }\r\n                catch (error) {\r\n                    console.error(`Unable to decode Vec on index ${index}`, error.message);\r\n                    throw error;\r\n                }\r\n            });\r\n        }\r\n        const u8a = u8aToU8a(value);\r\n        const [offset, length] = Compact.decodeU8a(u8a);\r\n        assert(length.lten(MAX_LENGTH), `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\r\n        return decodeU8a(u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\r\n    }\r\n    static with(Type) {\r\n        return class extends Vec {\r\n            constructor(value) {\r\n                super(Type, value);\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @description The type for the items\r\n     */\r\n    get Type() {\r\n        return this._Type.name;\r\n    }\r\n    /**\r\n     * @description Finds the index of the value in the array\r\n     */\r\n    indexOf(_other) {\r\n        // convert type first, this removes overhead from the eq\r\n        const other = _other instanceof this._Type\r\n            ? _other\r\n            : new this._Type(_other);\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (other.eq(this[i])) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return `Vec<${new this._Type().toRawType()}>`;\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Compact.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/utils/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/AbstractArray.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/codec/Vec.d.ts","writeByteOrderMark":false,"text":"import { Codec, Constructor, InterfaceTypes } from '../types';\r\nimport AbstractArray from './AbstractArray';\r\n/**\r\n * @name Vec\r\n * @description\r\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\r\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\r\n * specific encoding/decoding on top of the base type.\r\n */\r\nexport default class Vec<T extends Codec> extends AbstractArray<T> {\r\n    private _Type;\r\n    constructor(Type: Constructor<T> | InterfaceTypes, value?: Vec<any> | Uint8Array | string | any[]);\r\n    static decodeVec<T extends Codec>(Type: Constructor<T>, value: Vec<any> | Uint8Array | string | any[]): T[];\r\n    static with<O extends Codec>(Type: Constructor<O> | InterfaceTypes): Constructor<Vec<O>>;\r\n    /**\r\n     * @description The type for the items\r\n     */\r\n    readonly Type: string;\r\n    /**\r\n     * @description Finds the index of the value in the array\r\n     */\r\n    indexOf(_other?: any): number;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n}\r\n"}}
