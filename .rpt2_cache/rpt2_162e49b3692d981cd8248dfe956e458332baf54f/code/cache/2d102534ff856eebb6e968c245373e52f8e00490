{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\r\nimport Null from '../primitive/Null';\r\nimport { mapToTypeMap } from './utils';\r\nimport Base from './Base';\r\n/**\r\n * @name Enum\r\n * @description\r\n * This implements an enum, that based on the value wraps a different type. It is effectively\r\n * an extension to enum where the value type is determined by the actual index.\r\n */\r\n// TODO:\r\n//   - As per Enum, actually use TS enum\r\n//   - It should rather probably extend Enum instead of copying code\r\nexport default class Enum extends Base {\r\n    constructor(def, value, index) {\r\n        const defInfo = Enum.extractDef(def);\r\n        const decoded = Enum.decodeEnum(defInfo.def, value, index);\r\n        super(decoded.value);\r\n        this._def = defInfo.def;\r\n        this._isBasic = defInfo.isBasic;\r\n        this._indexes = Object.keys(defInfo.def).map((_, index) => index);\r\n        this._index = this._indexes.indexOf(decoded.index) || 0;\r\n    }\r\n    static extractDef(def) {\r\n        if (!Array.isArray(def)) {\r\n            return {\r\n                def: mapToTypeMap(def),\r\n                isBasic: false\r\n            };\r\n        }\r\n        return {\r\n            def: def.reduce((def, key) => {\r\n                def[key] = Null;\r\n                return def;\r\n            }, {}),\r\n            isBasic: true\r\n        };\r\n    }\r\n    static decodeEnum(def, value, index) {\r\n        // If `index` is set, we parse it.\r\n        if (index instanceof Enum) {\r\n            return Enum.createValue(def, index._index, index.raw);\r\n        }\r\n        else if (isNumber(index)) {\r\n            return Enum.createValue(def, index, value);\r\n        }\r\n        // Or else, we just look at `value`\r\n        return Enum.decodeViaValue(def, value);\r\n    }\r\n    static decodeViaValue(def, value) {\r\n        if (value instanceof Enum) {\r\n            return Enum.createValue(def, value._index, value.raw);\r\n        }\r\n        else if (isU8a(value)) {\r\n            return Enum.createValue(def, value[0], value.subarray(1));\r\n        }\r\n        else if (isNumber(value)) {\r\n            return Enum.createValue(def, value);\r\n        }\r\n        else if (isString(value)) {\r\n            const _str = value.toString();\r\n            return isHex(_str)\r\n                ? Enum.decodeViaValue(def, hexToU8a(_str))\r\n                : Enum.createViaJSON(def, _str);\r\n        }\r\n        else if (isObject(value)) {\r\n            const key = Object.keys(value)[0];\r\n            return Enum.createViaJSON(def, key, value[key]);\r\n        }\r\n        // Worst-case scenario, return the first with default\r\n        return Enum.createValue(def, 0);\r\n    }\r\n    static createViaJSON(def, key, value) {\r\n        // JSON comes in the form of { \"<type (lowercased)>\": \"<value for type>\" }, here we\r\n        // additionally force to lower to ensure forward compat\r\n        const keys = Object.keys(def).map((k) => k.toLowerCase());\r\n        const keyLower = key.toLowerCase();\r\n        const index = keys.indexOf(keyLower);\r\n        assert(index !== -1, `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\r\n        return Enum.createValue(def, index, value);\r\n    }\r\n    static createValue(def, index = 0, value) {\r\n        const Clazz = Object.values(def)[index];\r\n        assert(!isUndefined(Clazz), `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\r\n        return {\r\n            index,\r\n            value: new Clazz(value)\r\n        };\r\n    }\r\n    static with(Types) {\r\n        return class extends Enum {\r\n            constructor(value, index) {\r\n                super(Types, value, index);\r\n                Object.keys(this._def).forEach((_key) => {\r\n                    const name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\r\n                    const askey = `as${name}`;\r\n                    const iskey = `is${name}`;\r\n                    // do not clobber existing properties on the object\r\n                    if (isUndefined(this[iskey])) {\r\n                        Object.defineProperty(this, iskey, {\r\n                            enumerable: true,\r\n                            get: () => this.type === _key\r\n                        });\r\n                    }\r\n                    if (isUndefined(this[askey])) {\r\n                        Object.defineProperty(this, askey, {\r\n                            enumerable: true,\r\n                            get: () => {\r\n                                assert(this[iskey], `Cannot convert '${this.type}' via ${askey}`);\r\n                                return this.value;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        return 1 + this.raw.encodedLength;\r\n    }\r\n    /**\r\n     * @description The index of the metadata value\r\n     */\r\n    get index() {\r\n        return this._index;\r\n    }\r\n    /**\r\n     * @description Checks if the Enum points to a [[Null]] type\r\n     */\r\n    get isNone() {\r\n        return this.isNull;\r\n    }\r\n    /**\r\n     * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\r\n     */\r\n    get isNull() {\r\n        return this.raw instanceof Null;\r\n    }\r\n    /**\r\n     * @description The name of the type this enum value represents\r\n     */\r\n    get type() {\r\n        return Object.keys(this._def)[this._index];\r\n    }\r\n    /**\r\n     * @description The value of the enum\r\n     */\r\n    get value() {\r\n        return this.raw;\r\n    }\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other) {\r\n        // cater for the case where we only pass the enum index\r\n        if (isNumber(other)) {\r\n            return this.toNumber() === other;\r\n        }\r\n        else if (this._isBasic && isString(other)) {\r\n            return this.type === other;\r\n        }\r\n        // compare the actual wrapper value\r\n        return this.value.eq(other);\r\n    }\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex() {\r\n        return u8aToHex(this.toU8a());\r\n    }\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON() {\r\n        return this._isBasic\r\n            ? this._index\r\n            : { [this.type]: this.raw.toJSON() };\r\n    }\r\n    /**\r\n     * @description Returns the number representation for the value\r\n     */\r\n    toNumber() {\r\n        return this._index;\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        const _enum = this._isBasic\r\n            ? Object.keys(this._def)\r\n            : Object.entries(this._def).reduce((result, [key, Type]) => {\r\n                result[key] = new Type().toRawType();\r\n                return result;\r\n            }, {});\r\n        return JSON.stringify({ _enum });\r\n    }\r\n    /**\r\n     * @description Returns the string representation of the value\r\n     */\r\n    toString() {\r\n        return this.isNull\r\n            ? this.type\r\n            : JSON.stringify(this.toJSON());\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        const index = this._indexes[this._index];\r\n        return u8aConcat(new Uint8Array([index]), this.raw.toU8a(isBare));\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Null.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/utils/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Base.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/codec/EnumType.d.ts","writeByteOrderMark":false,"text":"import { AnyJson, Codec, Constructor, InterfaceTypes } from '../types';\r\nimport Base from './Base';\r\ninterface EnumConstructor<T = Codec> {\r\n    new (value?: any, index?: number): T;\r\n}\r\n/**\r\n * @name Enum\r\n * @description\r\n * This implements an enum, that based on the value wraps a different type. It is effectively\r\n * an extension to enum where the value type is determined by the actual index.\r\n */\r\nexport default class Enum extends Base<Codec> {\r\n    private _def;\r\n    private _index;\r\n    private _indexes;\r\n    private _isBasic;\r\n    constructor(def: Record<string, InterfaceTypes | Constructor> | string[], value?: any, index?: number | Enum);\r\n    private static extractDef;\r\n    private static decodeEnum;\r\n    private static decodeViaValue;\r\n    private static createViaJSON;\r\n    private static createValue;\r\n    static with(Types: Record<string, InterfaceTypes | Constructor> | string[]): EnumConstructor<Enum>;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description The index of the metadata value\r\n     */\r\n    readonly index: number;\r\n    /**\r\n     * @description Checks if the Enum points to a [[Null]] type\r\n     */\r\n    readonly isNone: boolean;\r\n    /**\r\n     * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\r\n     */\r\n    readonly isNull: boolean;\r\n    /**\r\n     * @description The name of the type this enum value represents\r\n     */\r\n    readonly type: string;\r\n    /**\r\n     * @description The value of the enum\r\n     */\r\n    readonly value: Codec;\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other?: any): boolean;\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex(): string;\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON(): AnyJson;\r\n    /**\r\n     * @description Returns the number representation for the value\r\n     */\r\n    toNumber(): number;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n    /**\r\n     * @description Returns the string representation of the value\r\n     */\r\n    toString(): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\nexport {};\r\n"}}
