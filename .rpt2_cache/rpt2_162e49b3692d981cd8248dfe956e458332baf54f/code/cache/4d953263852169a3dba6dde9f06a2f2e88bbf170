{"code":"// Copyright 2017-2019 @polkadot/api-derive authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport BN from 'bn.js';\r\nimport { combineLatest, of } from 'rxjs';\r\nimport { map, switchMap } from 'rxjs/operators';\r\nimport { createType } from '@polkadot/types';\r\nimport { isUndefined } from '@polkadot/util';\r\nimport { bestNumber } from '../chain/bestNumber';\r\nimport { eraLength } from '../session/eraLength';\r\nimport { recentlyOffline } from './recentlyOffline';\r\nimport { drr } from '../util/drr';\r\nfunction groupByEra(list) {\r\n    return list.reduce((map, { era, value }) => {\r\n        const key = era.toString();\r\n        map[key] = !map[key]\r\n            ? value.unwrap()\r\n            : map[key].add(value.unwrap());\r\n        return map;\r\n    }, {});\r\n}\r\nfunction remainingBlocks(era, eraLength, bestNumber) {\r\n    const remaining = eraLength.mul(era).sub(bestNumber);\r\n    return remaining.lten(0)\r\n        ? new BN(0)\r\n        : remaining;\r\n}\r\nfunction calculateUnlocking(stakingLedger, eraLength, bestNumber) {\r\n    if (isUndefined(stakingLedger)) {\r\n        return undefined;\r\n    }\r\n    // select the Unlockchunks that can't be redeemed yet.\r\n    const unlockingChunks = stakingLedger.unlocking.filter((chunk) => remainingBlocks(chunk.era.unwrap(), eraLength, bestNumber).gtn(0));\r\n    if (!unlockingChunks.length) {\r\n        return undefined;\r\n    }\r\n    // group the Unlockchunks that have the same era and sum their values\r\n    const groupedResult = groupByEra(unlockingChunks);\r\n    const results = Object.entries(groupedResult).map(([eraString, value]) => ({\r\n        value,\r\n        remainingBlocks: remainingBlocks(createType('BlockNumber', eraString), eraLength, bestNumber)\r\n    }));\r\n    return results.length ? results : undefined;\r\n}\r\nfunction redeemableSum(stakingLedger, eraLength, bestNumber) {\r\n    if (isUndefined(stakingLedger)) {\r\n        return new BN(0);\r\n    }\r\n    return stakingLedger.unlocking\r\n        .filter((chunk) => remainingBlocks(chunk.era.unwrap(), eraLength, bestNumber).eqn(0))\r\n        .reduce((curr, prev) => curr.add(prev.value.unwrap()), new BN(0));\r\n}\r\nfunction unwrapSessionIds(stashId, queuedKeys, nextKeys) {\r\n    // for 2.x we have a Vec<(ValidatorId,Keys)> of the keys\r\n    if (Array.isArray(queuedKeys)) {\r\n        const sessionIds = (queuedKeys.find(([currentId]) => currentId.eq(stashId)) || [undefined, []])[1];\r\n        const nextSessionIds = nextKeys.unwrapOr([]);\r\n        return {\r\n            nextSessionId: nextSessionIds[0],\r\n            nextSessionIds,\r\n            sessionId: sessionIds[0],\r\n            sessionIds\r\n        };\r\n    }\r\n    // substrate 1.x\r\n    const nextSessionIds = queuedKeys.isSome\r\n        ? [queuedKeys.unwrap()]\r\n        : [];\r\n    return {\r\n        nextSessionId: nextSessionIds[0],\r\n        nextSessionIds,\r\n        sessionId: nextSessionIds[0],\r\n        sessionIds: nextSessionIds\r\n    };\r\n}\r\nfunction retrieveMulti(api, stashId, controllerId) {\r\n    return combineLatest([\r\n        // TODO We really want this as part of the multi, however can only do that\r\n        // once we drop substrate 1.x support (nulti requires values for all)\r\n        api.query.session.nextKeys\r\n            ? api.query.session.nextKeys(api.consts.session.dedupKeyPrefix, stashId)\r\n            : of(createType('Option<Keys>', null)),\r\n        api.queryMulti([\r\n            api.query.session.queuedKeys\r\n                ? [api.query.session.queuedKeys]\r\n                : [api.query.session.nextKeyFor, controllerId],\r\n            [api.query.staking.ledger, controllerId],\r\n            [api.query.staking.nominators, stashId],\r\n            [api.query.staking.payee, stashId],\r\n            [api.query.staking.stakers, stashId],\r\n            [api.query.staking.validators, stashId]\r\n        ])\r\n    ]);\r\n}\r\nfunction retrieveInfo(api, stashId, controllerId) {\r\n    return combineLatest([\r\n        eraLength(api)(),\r\n        bestNumber(api)(),\r\n        recentlyOffline(api)(),\r\n        retrieveMulti(api, stashId, controllerId)\r\n    ]).pipe(map(([eraLength, bestNumber, recentlyOffline, [nextKeys, [queuedKeys, _stakingLedger, [nominators], rewardDestination, stakers, [validatorPrefs]]]]) => {\r\n        const stakingLedger = _stakingLedger.unwrapOr(undefined);\r\n        return {\r\n            accountId: stashId,\r\n            controllerId,\r\n            nominators,\r\n            offline: recentlyOffline[stashId.toString()],\r\n            redeemable: redeemableSum(stakingLedger, eraLength, bestNumber),\r\n            rewardDestination,\r\n            stakers,\r\n            stakingLedger,\r\n            stashId,\r\n            unlocking: calculateUnlocking(stakingLedger, eraLength, bestNumber),\r\n            validatorPrefs,\r\n            ...unwrapSessionIds(stashId, queuedKeys, nextKeys)\r\n        };\r\n    }));\r\n}\r\n/**\r\n * @description From a stash, retrieve the controllerId and fill in all the relevant staking details\r\n */\r\nexport function info(api) {\r\n    return (_accountId) => {\r\n        const accountId = createType('AccountId', _accountId);\r\n        return (\r\n        // NOTE For 2.x-only support, only the first path is required, therefore we\r\n        // can replace this with `.bonded<Option<AccountId>>(accountId)` - in 2.x\r\n        // the session.validators return the stashes (as expected)\r\n        api.queryMulti([\r\n            [api.query.staking.bonded, accountId],\r\n            [api.query.staking.ledger, accountId] // try to map to stash (1.x only)\r\n        ])).pipe(switchMap(([controllerId, stakingLedger]) => controllerId.isSome\r\n            ? retrieveInfo(api, accountId, controllerId.unwrap())\r\n            : stakingLedger.isSome\r\n                ? retrieveInfo(api, stakingLedger.unwrap().stash, accountId)\r\n                : of({ accountId, nextSessionIds: [], sessionIds: [] })), drr());\r\n    };\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/runtime/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/session/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/staking/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api-derive/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/bn.js/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/operators/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/index.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api-derive/src/chain/bestNumber.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api-derive/src/session/eraLength.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api-derive/src/staking/recentlyOffline.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api-derive/src/util/drr.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/api-derive/src/staking/info.d.ts","writeByteOrderMark":false,"text":"import { ApiInterfaceRx } from '@polkadot/api/types';\r\nimport { DerivedStaking } from '../types';\r\nimport { Observable } from 'rxjs';\r\n/**\r\n * @description From a stash, retrieve the controllerId and fill in all the relevant staking details\r\n */\r\nexport declare function info(api: ApiInterfaceRx): (_accountId: Uint8Array | string) => Observable<DerivedStaking>;\r\n"}}
