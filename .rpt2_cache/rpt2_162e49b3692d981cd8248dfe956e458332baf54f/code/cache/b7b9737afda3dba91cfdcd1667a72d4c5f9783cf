{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport Text from './Text';\r\nconst ALLOWED_BOXES = ['Compact', 'Option', 'Vec'];\r\n/**\r\n * @name Type\r\n * @description\r\n * This is a extended version of String, specifically to handle types. Here we rely fully\r\n * on what string provides us, however we also adjust the types received from the runtime,\r\n * i.e. we remove the `T::` prefixes found in some types for consistency accross implementation.\r\n */\r\nexport default class Type extends Text {\r\n    constructor(value = '') {\r\n        // First decode it with Text\r\n        const textValue = new Text(value);\r\n        // Then cleanup the textValue to get the @polkadot/types type, and pass the\r\n        // sanitized value to constructor\r\n        super(Type.decodeType(textValue.toString()));\r\n        this._originalLength = textValue.encodedLength;\r\n    }\r\n    static decodeType(value) {\r\n        const mappings = [\r\n            // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\r\n            Type._alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport'),\r\n            // alias TreasuryProposal from Proposal<T::AccountId, BalanceOf<T>>\r\n            Type._alias('Proposal<T::AccountId, BalanceOf<T>>', 'TreasuryProposal'),\r\n            // <T::Balance as HasCompact>\r\n            Type._cleanupCompact(),\r\n            // Remove all the trait prefixes\r\n            Type._removeTraits(),\r\n            // remove PairOf<T> -> (T, T)\r\n            Type._removePairOf(),\r\n            // remove boxing, `Box<Proposal>` -> `Proposal`\r\n            Type._removeWrap('Box'),\r\n            // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\r\n            Type._removeGenerics(),\r\n            // alias String -> Text (compat with jsonrpc methods)\r\n            Type._alias('String', 'Text'),\r\n            // alias () -> Null\r\n            Type._alias('\\\\(\\\\)', 'Null'),\r\n            // alias Vec<u8> -> Bytes\r\n            Type._alias('Vec<u8>', 'Bytes'),\r\n            // alias &[u8] -> Bytes\r\n            Type._alias('&\\\\[u8\\\\]', 'Bytes'),\r\n            // alias RawAddress -> Address\r\n            Type._alias('RawAddress', 'Address'),\r\n            // alias Lookup::Source to Address (_could_ be AccountId on certain chains)\r\n            Type._alias('Lookup::Source', 'Address'),\r\n            // alias Lookup::Target to AccountId (always the case)\r\n            Type._alias('Lookup::Target', 'AccountId'),\r\n            // alias for grandpa, as used in polkadot\r\n            Type._alias('grandpa::AuthorityId', 'AuthorityId'),\r\n            // specific for SessionIndex (could make this session::, but be conservative)\r\n            Type._alias('session::SessionIndex', 'SessionIndex'),\r\n            // HACK duplication between contracts & primitives, however contracts prefixed with exec\r\n            Type._alias('exec::StorageKey', 'ContractStorageKey'),\r\n            // flattens tuples with one value, `(AccountId)` -> `AccountId`\r\n            Type._flattenSingleTuple(),\r\n            // converts ::Type to Type, <T as Trait<I>>::Proposal -> ::Proposal\r\n            Type._removeColonPrefix()\r\n        ];\r\n        return mappings.reduce((result, fn) => {\r\n            return fn(result);\r\n        }, value).trim();\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        // NOTE Length is used in the decoding calculations, so return the original (pre-cleanup)\r\n        // length of the data. Since toU8a is disabled, this does not affect encoding, but rather\r\n        // only the decoding leg, allowing the decoders to work with original pointers\r\n        return this._originalLength;\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    toU8a(isBare) {\r\n        // Note Since we are mangling what we get in beyond recognition, we really should\r\n        // not allow the re-encoding. Additionally, this is probably more of a decoder-only\r\n        // helper, so treat it as such.\r\n        throw new Error('Type::toU8a: unimplemented');\r\n    }\r\n    // given a starting index, find the closing >\r\n    static _findClosing(value, start) {\r\n        let depth = 0;\r\n        for (let index = start; index < value.length; index++) {\r\n            if (value[index] === '>') {\r\n                if (!depth) {\r\n                    return index;\r\n                }\r\n                depth--;\r\n            }\r\n            else if (value[index] === '<') {\r\n                depth++;\r\n            }\r\n        }\r\n        throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\r\n    }\r\n    static _alias(src, dest) {\r\n        return (value) => {\r\n            return value.replace(new RegExp(src, 'g'), dest);\r\n        };\r\n    }\r\n    static _cleanupCompact() {\r\n        return (value) => {\r\n            for (let index = 0; index < value.length; index++) {\r\n                if (value[index] !== '<') {\r\n                    continue;\r\n                }\r\n                const end = Type._findClosing(value, index + 1) - 14;\r\n                if (value.substr(end, 14) === ' as HasCompact') {\r\n                    value = `Compact<${value.substr(index + 1, end - index - 1)}>`;\r\n                }\r\n            }\r\n            return value;\r\n        };\r\n    }\r\n    static _flattenSingleTuple() {\r\n        return (value) => {\r\n            return value.replace(/\\(([^,]*)\\)/, '$1');\r\n        };\r\n    }\r\n    static _removeColonPrefix() {\r\n        return (value) => {\r\n            return value.replace(/^::/, '');\r\n        };\r\n    }\r\n    static _removeGenerics() {\r\n        return (value) => {\r\n            for (let index = 0; index < value.length; index++) {\r\n                if (value[index] === '<') {\r\n                    // check against the allowed wrappers, be it Vec<..>, Option<...> ...\r\n                    const box = ALLOWED_BOXES.find((box) => {\r\n                        const start = index - box.length;\r\n                        return start >= 0 && value.substr(start, box.length) === box;\r\n                    });\r\n                    // we have not found anything, unwrap generic innards\r\n                    if (!box) {\r\n                        const end = Type._findClosing(value, index + 1);\r\n                        value = `${value.substr(0, index)}${value.substr(end + 1)}`;\r\n                    }\r\n                }\r\n            }\r\n            return value;\r\n        };\r\n    }\r\n    // remove the PairOf wrappers\r\n    static _removePairOf() {\r\n        return (value) => {\r\n            for (let index = 0; index < value.length; index++) {\r\n                if (value.substr(index, 7) === 'PairOf<') {\r\n                    const start = index + 7;\r\n                    const end = Type._findClosing(value, start);\r\n                    const type = value.substr(start, end - start);\r\n                    value = `${value.substr(0, index)}(${type},${type})${value.substr(end + 1)}`;\r\n                }\r\n            }\r\n            return value;\r\n        };\r\n    }\r\n    // remove the type traits\r\n    static _removeTraits() {\r\n        return (value) => {\r\n            return value\r\n                // remove all whitespaces\r\n                .replace(/\\s/g, '')\r\n                // anything `T::<type>` to end up as `<type>`\r\n                .replace(/T::/g, '')\r\n                // anything `Self::<type>` to end up as `<type>`\r\n                .replace(/Self::/g, '')\r\n                // `system::` with `` - basically we find `<T as system::Trait>`\r\n                .replace(/system::/g, '')\r\n                // replace `<T as Trait>::` (whitespaces were removed above)\r\n                .replace(/<TasTrait>::/g, '')\r\n                // replace `<T as something::Trait>::` (whitespaces were removed above)\r\n                .replace(/<Tas[a-z]+::Trait>::/g, '')\r\n                // replace `<Self as Trait>::` (whitespaces were removed above)\r\n                .replace(/<SelfasTrait>::/g, '')\r\n                // replace <Lookup as StaticLookup>\r\n                .replace(/<LookupasStaticLookup>/g, 'Lookup')\r\n                // replace `<...>::Type`\r\n                .replace(/::Type/g, '')\r\n                // replace `wasm::*` eg. `wasm::PrefabWasmModule`\r\n                .replace(/wasm::/g, '')\r\n                // `sr_std::marker::`\r\n                .replace(/sr_std::marker::/g, '');\r\n        };\r\n    }\r\n    // remove wrapping values, i.e. Box<Proposal> -> Proposal\r\n    static _removeWrap(_check) {\r\n        const check = `${_check}<`;\r\n        return (value) => {\r\n            let index = 0;\r\n            while (index !== -1) {\r\n                index = value.indexOf(check);\r\n                if (index !== -1) {\r\n                    const start = index + check.length;\r\n                    const end = Type._findClosing(value, start);\r\n                    value = `${value.substr(0, index)}${value.substr(start, end - start)}${value.substr(end + 1)}`;\r\n                }\r\n            }\r\n            return value;\r\n        };\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return 'Type';\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Text.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Type.d.ts","writeByteOrderMark":false,"text":"import Text from './Text';\r\n/**\r\n * @name Type\r\n * @description\r\n * This is a extended version of String, specifically to handle types. Here we rely fully\r\n * on what string provides us, however we also adjust the types received from the runtime,\r\n * i.e. we remove the `T::` prefixes found in some types for consistency accross implementation.\r\n */\r\nexport default class Type extends Text {\r\n    private _originalLength;\r\n    constructor(value?: Text | Uint8Array | string);\r\n    private static decodeType;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n    private static _findClosing;\r\n    private static _alias;\r\n    private static _cleanupCompact;\r\n    private static _flattenSingleTuple;\r\n    private static _removeColonPrefix;\r\n    private static _removeGenerics;\r\n    private static _removePairOf;\r\n    private static _removeTraits;\r\n    private static _removeWrap;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n}\r\n"}}
