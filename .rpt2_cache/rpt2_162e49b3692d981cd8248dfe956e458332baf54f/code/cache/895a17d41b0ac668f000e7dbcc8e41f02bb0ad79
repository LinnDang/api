{"code":"// Copyright 2017-2019 @polkadot/api authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { from } from 'rxjs';\r\nimport ApiBase from '../Base';\r\n/**\r\n * # @polkadot/api/rx\r\n *\r\n *  ## Overview\r\n *\r\n * @name ApiRx\r\n *\r\n * @description\r\n * ApiRx is a powerfull RxJS Observable wrapper around the RPC and interfaces on the Polkadot network. As a full Observable API, all interface calls return RxJS Observables, including the static `.create(...)`. In the same fashion and subscription-based methods return long-running Observables that update with the latest values.\r\n *\r\n * The API is well suited to real-time applications where the latest state is needed, unlocking the subscription-based features of Polkadot (and Substrate) clients. Some familiarity with RxJS is a requirement to use the API, however just understanding `.subscribe` and `.pipe` on Observables will unlock full-scale use thereof.\r\n *\r\n * @see [[ApiPromise]]\r\n *\r\n * ## Usage\r\n *\r\n * Making rpc calls -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import ApiRx from '@polkadot/api/rx';\r\n *\r\n * // initialise via Promise & static create\r\n * const api = await ApiRx.create().toPromise();\r\n *\r\n * // make a call to retrieve the current network head\r\n * api.rpc.chain.subscribeNewHead().subscribe((header) => {\r\n *   console.log(`Chain is at #${header.number}`);\r\n * });\r\n * ```\r\n * <BR>\r\n *\r\n * Subscribing to chain state -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import { combineLatest } from 'rxjs';\r\n * import { pairwise, switchMap } from 'rxjs/operators';\r\n * import { ApiRx, WsProvider } from '@polkadot/api';\r\n *\r\n *\r\n * // initialise a provider with a specific endpoint\r\n * const provider = new WsProvider('wss://example.com:9944')\r\n *\r\n * // initialise via isReady & new with specific provider\r\n * new ApiRx({ provider })\r\n *   .isReady\r\n *   .pipe(\r\n *     switchMap((api) =>\r\n *       combineLatest([\r\n *         api.query.timestamp.blockPeriod(),\r\n *         api.query.timestamp.now().pipe(pairwise())\r\n *       ])\r\n *     )\r\n *   )\r\n *   .subscribe(([blockPeriod, timestamp]) => {\r\n *      const elapsed = timestamp[1].toNumber() - timestamp[0].toNumber();\r\n *      console.log(`timestamp ${timestamp[1]} \\nelapsed ${elapsed} \\n(${blockPeriod}s target)`);\r\n *   });\r\n * ```\r\n * <BR>\r\n *\r\n * Submitting a transaction -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import { first, switchMap } from 'rxjs/operators';\r\n * import ApiRx from '@polkadot/api/rx';\r\n *\r\n * // import the test keyring (already has dev keys for Alice, Bob, Charlie, Eve & Ferdie)\r\n * import testingPairs from '@polkadot/keyring/testingPairs';\r\n * const keyring = testingPairs();\r\n *\r\n * // get api via Promise\r\n * const api = await ApiRx.create().toPromise();\r\n *\r\n * // retrieve nonce for the account\r\n * api.query.system\r\n *   .accountNonce(keyring.alice.address)\r\n *   .pipe(\r\n *      first(),\r\n *      // pipe nonce into transfer\r\n *      switchMap((nonce) =>\r\n *        api.tx.balances\r\n *          // create transfer\r\n *          .transfer(keyring.bob.address, 12345)\r\n *          // sign the transcation\r\n *          .sign(keyring.alice, { nonce })\r\n *          // send the transaction\r\n *          .send()\r\n *      )\r\n *   )\r\n *   // subscribe to overall result\r\n *   .subscribe(({ status }) => {\r\n *     if (status.isFinalized) {\r\n *       console.log('Completed at block hash', status.asFinalized.toHex());\r\n *     }\r\n *   });\r\n * ```\r\n */\r\nexport default class ApiRx extends ApiBase {\r\n    /**\r\n     * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.\r\n     *\r\n     * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or [[WsProvider]]\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import { switchMap } from 'rxjs/operators';\r\n     * import Api from '@polkadot/api/rx';\r\n     *\r\n     * Api.create()\r\n     *   .pipe(\r\n     *     switchMap((api) =>\r\n     *       api.rpc.chain.subscribeNewHead()\r\n     *   ))\r\n     *   .subscribe((header) => {\r\n     *     console.log(`new block #${header.number.toNumber()}`);\r\n     *   });\r\n     * ```\r\n     */\r\n    static create(options) {\r\n        return new ApiRx(options).isReady;\r\n    }\r\n    /**\r\n     * @description Create an instance of the ApiRx class\r\n     *\r\n     * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import { switchMap } from 'rxjs/operators';\r\n     * import Api from '@polkadot/api/rx';\r\n     *\r\n     * new Api().isReady\r\n     *   .pipe(\r\n     *     switchMap((api) =>\r\n     *       api.rpc.chain.subscribeNewHead()\r\n     *   ))\r\n     *   .subscribe((header) => {\r\n     *     console.log(`new block #${header.number.toNumber()}`);\r\n     *   });\r\n     * ```\r\n     */\r\n    constructor(options) {\r\n        super(options, 'rxjs');\r\n        this._isReadyRx = from(\r\n        // convinced you can observable from an event, however my mind groks this form better\r\n        new Promise((resolve) => {\r\n            super.on('ready', () => {\r\n                resolve(this);\r\n            });\r\n        }));\r\n    }\r\n    /**\r\n     * @description Observable that carries the connected state for the provider. Results in a boolean flag that is true/false based on the connectivity.\r\n     */\r\n    get isConnected() {\r\n        return this._isConnected;\r\n    }\r\n    /**\r\n     * @description Observable that returns the first time we are connected and loaded\r\n     */\r\n    get isReady() {\r\n        return this._isReadyRx;\r\n    }\r\n    /**\r\n     * @description Returns a clone of this ApiRx instance (new underlying provider connection)\r\n     */\r\n    clone() {\r\n        return new ApiRx({\r\n            ...this._options,\r\n            source: this\r\n        });\r\n    }\r\n    decorateMethod(method) {\r\n        return method;\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/Base.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/api/src/rx/Api.d.ts","writeByteOrderMark":false,"text":"import { AnyFunction } from '@polkadot/types/types';\r\nimport { ApiOptions } from '../types';\r\nimport { Observable } from 'rxjs';\r\nimport ApiBase from '../Base';\r\n/**\r\n * # @polkadot/api/rx\r\n *\r\n *  ## Overview\r\n *\r\n * @name ApiRx\r\n *\r\n * @description\r\n * ApiRx is a powerfull RxJS Observable wrapper around the RPC and interfaces on the Polkadot network. As a full Observable API, all interface calls return RxJS Observables, including the static `.create(...)`. In the same fashion and subscription-based methods return long-running Observables that update with the latest values.\r\n *\r\n * The API is well suited to real-time applications where the latest state is needed, unlocking the subscription-based features of Polkadot (and Substrate) clients. Some familiarity with RxJS is a requirement to use the API, however just understanding `.subscribe` and `.pipe` on Observables will unlock full-scale use thereof.\r\n *\r\n * @see [[ApiPromise]]\r\n *\r\n * ## Usage\r\n *\r\n * Making rpc calls -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import ApiRx from '@polkadot/api/rx';\r\n *\r\n * // initialise via Promise & static create\r\n * const api = await ApiRx.create().toPromise();\r\n *\r\n * // make a call to retrieve the current network head\r\n * api.rpc.chain.subscribeNewHead().subscribe((header) => {\r\n *   console.log(`Chain is at #${header.number}`);\r\n * });\r\n * ```\r\n * <BR>\r\n *\r\n * Subscribing to chain state -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import { combineLatest } from 'rxjs';\r\n * import { pairwise, switchMap } from 'rxjs/operators';\r\n * import { ApiRx, WsProvider } from '@polkadot/api';\r\n *\r\n *\r\n * // initialise a provider with a specific endpoint\r\n * const provider = new WsProvider('wss://example.com:9944')\r\n *\r\n * // initialise via isReady & new with specific provider\r\n * new ApiRx({ provider })\r\n *   .isReady\r\n *   .pipe(\r\n *     switchMap((api) =>\r\n *       combineLatest([\r\n *         api.query.timestamp.blockPeriod(),\r\n *         api.query.timestamp.now().pipe(pairwise())\r\n *       ])\r\n *     )\r\n *   )\r\n *   .subscribe(([blockPeriod, timestamp]) => {\r\n *      const elapsed = timestamp[1].toNumber() - timestamp[0].toNumber();\r\n *      console.log(`timestamp ${timestamp[1]} \\nelapsed ${elapsed} \\n(${blockPeriod}s target)`);\r\n *   });\r\n * ```\r\n * <BR>\r\n *\r\n * Submitting a transaction -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import { first, switchMap } from 'rxjs/operators';\r\n * import ApiRx from '@polkadot/api/rx';\r\n *\r\n * // import the test keyring (already has dev keys for Alice, Bob, Charlie, Eve & Ferdie)\r\n * import testingPairs from '@polkadot/keyring/testingPairs';\r\n * const keyring = testingPairs();\r\n *\r\n * // get api via Promise\r\n * const api = await ApiRx.create().toPromise();\r\n *\r\n * // retrieve nonce for the account\r\n * api.query.system\r\n *   .accountNonce(keyring.alice.address)\r\n *   .pipe(\r\n *      first(),\r\n *      // pipe nonce into transfer\r\n *      switchMap((nonce) =>\r\n *        api.tx.balances\r\n *          // create transfer\r\n *          .transfer(keyring.bob.address, 12345)\r\n *          // sign the transcation\r\n *          .sign(keyring.alice, { nonce })\r\n *          // send the transaction\r\n *          .send()\r\n *      )\r\n *   )\r\n *   // subscribe to overall result\r\n *   .subscribe(({ status }) => {\r\n *     if (status.isFinalized) {\r\n *       console.log('Completed at block hash', status.asFinalized.toHex());\r\n *     }\r\n *   });\r\n * ```\r\n */\r\nexport default class ApiRx extends ApiBase<'rxjs'> {\r\n    private _isReadyRx;\r\n    /**\r\n     * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.\r\n     *\r\n     * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or [[WsProvider]]\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import { switchMap } from 'rxjs/operators';\r\n     * import Api from '@polkadot/api/rx';\r\n     *\r\n     * Api.create()\r\n     *   .pipe(\r\n     *     switchMap((api) =>\r\n     *       api.rpc.chain.subscribeNewHead()\r\n     *   ))\r\n     *   .subscribe((header) => {\r\n     *     console.log(`new block #${header.number.toNumber()}`);\r\n     *   });\r\n     * ```\r\n     */\r\n    static create(options?: ApiOptions): Observable<ApiRx>;\r\n    /**\r\n     * @description Create an instance of the ApiRx class\r\n     *\r\n     * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import { switchMap } from 'rxjs/operators';\r\n     * import Api from '@polkadot/api/rx';\r\n     *\r\n     * new Api().isReady\r\n     *   .pipe(\r\n     *     switchMap((api) =>\r\n     *       api.rpc.chain.subscribeNewHead()\r\n     *   ))\r\n     *   .subscribe((header) => {\r\n     *     console.log(`new block #${header.number.toNumber()}`);\r\n     *   });\r\n     * ```\r\n     */\r\n    constructor(options?: ApiOptions);\r\n    /**\r\n     * @description Observable that carries the connected state for the provider. Results in a boolean flag that is true/false based on the connectivity.\r\n     */\r\n    readonly isConnected: Observable<boolean>;\r\n    /**\r\n     * @description Observable that returns the first time we are connected and loaded\r\n     */\r\n    readonly isReady: Observable<ApiRx>;\r\n    /**\r\n     * @description Returns a clone of this ApiRx instance (new underlying provider connection)\r\n     */\r\n    clone(): ApiRx;\r\n    protected decorateMethod<Method extends AnyFunction>(method: Method): Method;\r\n}\r\n"}}
