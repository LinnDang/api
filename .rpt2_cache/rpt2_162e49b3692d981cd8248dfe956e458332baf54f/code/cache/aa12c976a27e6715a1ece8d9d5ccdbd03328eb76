{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\r\nimport Null from '../primitive/Null';\r\nimport { typeToConstructor } from './utils';\r\nimport Base from './Base';\r\n/**\r\n * @name Option\r\n * @description\r\n * An Option is an optional field. Basically the first byte indicates that there is\r\n * is value to follow. If the byte is `1` there is an actual value. So the Option\r\n * implements that - decodes, checks for optionality and wraps the required structure\r\n * with a value if/as required/found.\r\n */\r\nexport default class Option extends Base {\r\n    constructor(Type, value) {\r\n        const Clazz = typeToConstructor(Type);\r\n        super(Option.decodeOption(Clazz, value));\r\n        this._Type = Clazz;\r\n    }\r\n    static decodeOption(Type, value) {\r\n        if (isNull(value) || isUndefined(value) || value instanceof Null) {\r\n            return new Null();\r\n        }\r\n        else if (value instanceof Option) {\r\n            return Option.decodeOption(Type, value.value);\r\n        }\r\n        else if (value instanceof Type) {\r\n            // don't re-create, use as it (which also caters for derived types)\r\n            return value;\r\n        }\r\n        else if (isU8a(value)) {\r\n            // the isU8a check happens last in the if-tree - since the wrapped value\r\n            // may be an instance of it, so Type and Option checks go in first\r\n            return !value.length || value[0] === 0\r\n                ? new Null()\r\n                : new Type(value.subarray(1));\r\n        }\r\n        return new Type(value);\r\n    }\r\n    static with(Type) {\r\n        return class extends Option {\r\n            constructor(value) {\r\n                super(Type, value);\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        // boolean byte (has value, doesn't have) along with wrapped length\r\n        return 1 + this.raw.encodedLength;\r\n    }\r\n    /**\r\n     * @description Checks if the Option has no value\r\n     */\r\n    get isEmpty() {\r\n        return this.isNone;\r\n    }\r\n    /**\r\n     * @description Checks if the Option has no value\r\n     */\r\n    get isNone() {\r\n        return this.raw instanceof Null;\r\n    }\r\n    /**\r\n     * @description Checks if the Option has a value\r\n     */\r\n    get isSome() {\r\n        return !this.isNone;\r\n    }\r\n    /**\r\n     * @description The actual value for the Option\r\n     */\r\n    get value() {\r\n        return this.raw;\r\n    }\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other) {\r\n        if (other instanceof Option) {\r\n            return (this.isSome === other.isSome) && this.value.eq(other.value);\r\n        }\r\n        return this.value.eq(other);\r\n    }\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex() {\r\n        // This attempts to align with the JSON encoding - actually in this case\r\n        // the isSome value is correct, however the `isNone` may be problematic\r\n        return this.isNone\r\n            ? '0x'\r\n            : u8aToHex(this.toU8a().subarray(1));\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(isBare) {\r\n        const wrapped = new this._Type().toRawType();\r\n        return isBare\r\n            ? wrapped\r\n            : `Option<${wrapped}>`;\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        if (isBare) {\r\n            return this.raw.toU8a(true);\r\n        }\r\n        const u8a = new Uint8Array(this.encodedLength);\r\n        if (this.isSome) {\r\n            u8a.set([1]);\r\n            u8a.set(this.raw.toU8a(), 1);\r\n        }\r\n        return u8a;\r\n    }\r\n    /**\r\n     * @description Returns the value that the Option represents (if available), throws if null\r\n     */\r\n    unwrap() {\r\n        if (this.isNone) {\r\n            throw new Error('Option: unwrapping a None value');\r\n        }\r\n        return this.raw;\r\n    }\r\n    /**\r\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\r\n     * @param defaultValue The value to return if the option isNone\r\n     */\r\n    unwrapOr(defaultValue) {\r\n        return this.isSome\r\n            ? this.unwrap()\r\n            : defaultValue;\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Null.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/utils/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Base.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/codec/Option.d.ts","writeByteOrderMark":false,"text":"import { Codec, Constructor, InterfaceTypes } from '../types';\r\nimport Base from './Base';\r\n/**\r\n * @name Option\r\n * @description\r\n * An Option is an optional field. Basically the first byte indicates that there is\r\n * is value to follow. If the byte is `1` there is an actual value. So the Option\r\n * implements that - decodes, checks for optionality and wraps the required structure\r\n * with a value if/as required/found.\r\n */\r\nexport default class Option<T extends Codec> extends Base<T> {\r\n    private _Type;\r\n    constructor(Type: Constructor | InterfaceTypes, value?: any);\r\n    static decodeOption(Type: Constructor, value?: any): Codec;\r\n    static with<O extends Codec>(Type: Constructor | InterfaceTypes): Constructor<Option<O>>;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description Checks if the Option has no value\r\n     */\r\n    readonly isEmpty: boolean;\r\n    /**\r\n     * @description Checks if the Option has no value\r\n     */\r\n    readonly isNone: boolean;\r\n    /**\r\n     * @description Checks if the Option has a value\r\n     */\r\n    readonly isSome: boolean;\r\n    /**\r\n     * @description The actual value for the Option\r\n     */\r\n    readonly value: Codec;\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other?: any): boolean;\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex(): string;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(isBare?: boolean): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n    /**\r\n     * @description Returns the value that the Option represents (if available), throws if null\r\n     */\r\n    unwrap(): T;\r\n    /**\r\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\r\n     * @param defaultValue The value to return if the option isNone\r\n     */\r\n    unwrapOr<O>(defaultValue: O): T | O;\r\n}\r\n"}}
