{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { assert, isHex, isU8a, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\r\nimport Base from '../../codec/Base';\r\nimport Compact from '../../codec/Compact';\r\nimport Call from '../Generic/Call';\r\nimport ExtrinsicV1 from './v1/Extrinsic';\r\nimport ExtrinsicV2 from './v2/Extrinsic';\r\nimport ExtrinsicV3 from './v3/Extrinsic';\r\nimport { BIT_SIGNED, BIT_UNSIGNED, DEFAULT_VERSION, UNMASK_VERSION } from './constants';\r\n/**\r\n * @name Extrinsic\r\n * @description\r\n * Representation of an Extrinsic in the system. It contains the actual call,\r\n * (optional) signature and encodes with an actual length prefix\r\n *\r\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\r\n *\r\n * Can be:\r\n * - signed, to create a transaction\r\n * - left as is, to create an inherent\r\n */\r\nexport default class Extrinsic extends Base {\r\n    constructor(value, { version } = {}) {\r\n        super(Extrinsic.decodeExtrinsic(value, version));\r\n    }\r\n    static newFromValue(value, version) {\r\n        if (value instanceof Extrinsic) {\r\n            return value.raw;\r\n        }\r\n        const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;\r\n        const type = version & UNMASK_VERSION;\r\n        switch (type) {\r\n            case 1: return new ExtrinsicV1(value, { isSigned });\r\n            case 2: return new ExtrinsicV2(value, { isSigned });\r\n            case 3: return new ExtrinsicV3(value, { isSigned });\r\n            default: throw new Error(`Unsupported extrinsic version ${type}`);\r\n        }\r\n    }\r\n    static decodeExtrinsic(value, version = DEFAULT_VERSION) {\r\n        if (Array.isArray(value) || isHex(value)) {\r\n            // Instead of the block below, it should simply be:\r\n            // return Extrinsic.decodeExtrinsic(hexToU8a(value as string));\r\n            const u8a = u8aToU8a(value);\r\n            // HACK 11 Jan 2019 - before https://github.com/paritytech/substrate/pull/1388\r\n            // extrinsics didn't have the length, cater for both approaches\r\n            const [offset, length] = Compact.decodeU8a(u8a);\r\n            const withPrefix = u8a.length === (offset + length.toNumber());\r\n            return Extrinsic.decodeExtrinsic(withPrefix\r\n                ? u8a\r\n                : Compact.addLengthPrefix(u8a), version);\r\n        }\r\n        else if (isU8a(value)) {\r\n            if (!value.length) {\r\n                return Extrinsic.newFromValue(new Uint8Array(), version);\r\n            }\r\n            const [offset, length] = Compact.decodeU8a(value);\r\n            const total = offset + length.toNumber();\r\n            assert(total <= value.length, `Extrinsic: required length less than remainder, expected at least ${total}, found ${value.length}`);\r\n            return Extrinsic.decodeU8a(value.subarray(offset, total));\r\n        }\r\n        else if (value instanceof Call) {\r\n            return Extrinsic.newFromValue({ method: value }, version);\r\n        }\r\n        return Extrinsic.newFromValue(value, version);\r\n    }\r\n    static decodeU8a(value) {\r\n        return Extrinsic.newFromValue(value.subarray(1), value[0]);\r\n    }\r\n    /**\r\n     * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\r\n     */\r\n    get args() {\r\n        return this.method.args;\r\n    }\r\n    /**\r\n     * @description Thge argument defintions, compatible with [[Call]]\r\n     */\r\n    get argsDef() {\r\n        return this.method.argsDef;\r\n    }\r\n    /**\r\n     * @description The actual `[sectionIndex, methodIndex]` as used in the Call\r\n     */\r\n    get callIndex() {\r\n        return this.method.callIndex;\r\n    }\r\n    /**\r\n     * @description The actual data for the Call\r\n     */\r\n    get data() {\r\n        return this.method.data;\r\n    }\r\n    /**\r\n     * @description The era for thios extrinsic\r\n     */\r\n    get era() {\r\n        return this.raw.signature.era;\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        return this.toU8a().length;\r\n    }\r\n    /**\r\n     * @description `true` is method has `Origin` argument (compatibility with [Call])\r\n     */\r\n    get hasOrigin() {\r\n        return this.method.hasOrigin;\r\n    }\r\n    /**\r\n     * @description `true` id the extrinsic is signed\r\n     */\r\n    get isSigned() {\r\n        return this.raw.signature.isSigned;\r\n    }\r\n    /**\r\n     * @description The length of the actual data, excluding prefix\r\n     */\r\n    get length() {\r\n        return this.toU8a(true).length;\r\n    }\r\n    /**\r\n     * @description The [[FunctionMetadata]] that describes the extrinsic\r\n     */\r\n    get meta() {\r\n        return this.method.meta;\r\n    }\r\n    /**\r\n     * @description The [[Call]] this extrinsic wraps\r\n     */\r\n    get method() {\r\n        return this.raw.method;\r\n    }\r\n    /**\r\n     * @description The nonce for this extrinsic\r\n     */\r\n    get nonce() {\r\n        return this.raw.signature.nonce;\r\n    }\r\n    /**\r\n     * @description The [[ExtrinsicSignature]]\r\n     */\r\n    get signature() {\r\n        return this.raw.signature.signature;\r\n    }\r\n    /**\r\n     * @description The [[Address]] that signed\r\n     */\r\n    get signer() {\r\n        return this.raw.signature.signer;\r\n    }\r\n    /**\r\n     * @description Forwards compat\r\n     */\r\n    get tip() {\r\n        return this.raw.signature.tip;\r\n    }\r\n    /**\r\n     * @description Returns the raw transaction version (not flagged with signing information)\r\n    */\r\n    get type() {\r\n        return this.raw.version;\r\n    }\r\n    /**\r\n     * @description Returns the encoded version flag\r\n    */\r\n    get version() {\r\n        return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);\r\n    }\r\n    /**\r\n     * @description Add an [[ExtrinsicSignature]] to the extrinsic (already generated)\r\n     */\r\n    addSignature(signer, signature, ...args) {\r\n        // FIXME Support for current extensions where 2 values are being passed in here, i.e.\r\n        //   addSignature(signer, signature, nonce, era);\r\n        // The above signature should be changed to the correct format in the next cycle, i.e.\r\n        //   payload: ExtrinsicPayloadValue | Uint8Array | string\r\n        let payload = args[0];\r\n        // @ts-ignore\r\n        if (args.length === 2) {\r\n            payload = {\r\n                blockHash: new Uint8Array(),\r\n                // @ts-ignore\r\n                era: args[1],\r\n                genesisHash: new Uint8Array(),\r\n                method: this.method.toHex(),\r\n                nonce: args[0],\r\n                tip: 0\r\n            };\r\n        }\r\n        this.raw.addSignature(signer, signature, payload);\r\n        return this;\r\n    }\r\n    /**\r\n     * @description Sign the extrinsic with a specific keypair\r\n     */\r\n    sign(account, options) {\r\n        this.raw.sign(account, options);\r\n        return this;\r\n    }\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex() {\r\n        return u8aToHex(this.toU8a());\r\n    }\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON() {\r\n        return this.toHex();\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return 'Extrinsic';\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        const encoded = u8aConcat(new Uint8Array([this.version]), this.raw.toU8a(isBare));\r\n        return isBare\r\n            ? encoded\r\n            : Compact.addLengthPrefix(encoded);\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/runtime/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Base.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Compact.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/Metadata/v7/Calls.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Generic/Address.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Generic/Call.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/v1/Extrinsic.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/v2/Extrinsic.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/v3/Extrinsic.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/ExtrinsicEra.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/constants.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Extrinsic/Extrinsic.d.ts","writeByteOrderMark":false,"text":"import { Balance, Index } from '../../interfaces/runtime';\r\nimport { AnyU8a, ArgsDef, Codec, ExtrinsicPayloadValue, IExtrinsic, IHash, IKeyringPair, SignatureOptions } from '../../types';\r\nimport Base from '../../codec/Base';\r\nimport Compact from '../../codec/Compact';\r\nimport { FunctionMetadata } from '../../Metadata/v7/Calls';\r\nimport Address from '../Generic/Address';\r\nimport Call from '../Generic/Call';\r\nimport ExtrinsicV1, { ExtrinsicValueV1 } from './v1/Extrinsic';\r\nimport ExtrinsicV2, { ExtrinsicValueV2 } from './v2/Extrinsic';\r\nimport ExtrinsicV3, { ExtrinsicValueV3 } from './v3/Extrinsic';\r\nimport ExtrinsicEra from './ExtrinsicEra';\r\ndeclare type ExtrinsicValue = ExtrinsicValueV1 | ExtrinsicValueV2 | ExtrinsicValueV3;\r\ninterface ExtrinsicOptions {\r\n    version?: number;\r\n}\r\n/**\r\n * @name Extrinsic\r\n * @description\r\n * Representation of an Extrinsic in the system. It contains the actual call,\r\n * (optional) signature and encodes with an actual length prefix\r\n *\r\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\r\n *\r\n * Can be:\r\n * - signed, to create a transaction\r\n * - left as is, to create an inherent\r\n */\r\nexport default class Extrinsic extends Base<ExtrinsicV1 | ExtrinsicV2 | ExtrinsicV3> implements IExtrinsic {\r\n    constructor(value: Extrinsic | ExtrinsicValue | AnyU8a | Call | undefined, { version }?: ExtrinsicOptions);\r\n    private static newFromValue;\r\n    static decodeExtrinsic(value: Extrinsic | ExtrinsicValue | AnyU8a | Call | undefined, version?: number): ExtrinsicV1 | ExtrinsicV2 | ExtrinsicV3;\r\n    private static decodeU8a;\r\n    /**\r\n     * @description The arguments passed to for the call, exposes args so it is compatible with [[Call]]\r\n     */\r\n    readonly args: Codec[];\r\n    /**\r\n     * @description Thge argument defintions, compatible with [[Call]]\r\n     */\r\n    readonly argsDef: ArgsDef;\r\n    /**\r\n     * @description The actual `[sectionIndex, methodIndex]` as used in the Call\r\n     */\r\n    readonly callIndex: Uint8Array;\r\n    /**\r\n     * @description The actual data for the Call\r\n     */\r\n    readonly data: Uint8Array;\r\n    /**\r\n     * @description The era for thios extrinsic\r\n     */\r\n    readonly era: ExtrinsicEra;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description `true` is method has `Origin` argument (compatibility with [Call])\r\n     */\r\n    readonly hasOrigin: boolean;\r\n    /**\r\n     * @description `true` id the extrinsic is signed\r\n     */\r\n    readonly isSigned: boolean;\r\n    /**\r\n     * @description The length of the actual data, excluding prefix\r\n     */\r\n    readonly length: number;\r\n    /**\r\n     * @description The [[FunctionMetadata]] that describes the extrinsic\r\n     */\r\n    readonly meta: FunctionMetadata;\r\n    /**\r\n     * @description The [[Call]] this extrinsic wraps\r\n     */\r\n    readonly method: Call;\r\n    /**\r\n     * @description The nonce for this extrinsic\r\n     */\r\n    readonly nonce: Compact<Index>;\r\n    /**\r\n     * @description The [[ExtrinsicSignature]]\r\n     */\r\n    readonly signature: IHash;\r\n    /**\r\n     * @description The [[Address]] that signed\r\n     */\r\n    readonly signer: Address;\r\n    /**\r\n     * @description Forwards compat\r\n     */\r\n    readonly tip: Compact<Balance>;\r\n    /**\r\n     * @description Returns the raw transaction version (not flagged with signing information)\r\n    */\r\n    readonly type: number;\r\n    /**\r\n     * @description Returns the encoded version flag\r\n    */\r\n    readonly version: number;\r\n    /**\r\n     * @description Add an [[ExtrinsicSignature]] to the extrinsic (already generated)\r\n     */\r\n    addSignature(signer: Address | Uint8Array | string, signature: Uint8Array | string, ...args: [ExtrinsicPayloadValue | Uint8Array | string]): Extrinsic;\r\n    /**\r\n     * @description Sign the extrinsic with a specific keypair\r\n     */\r\n    sign(account: IKeyringPair, options: SignatureOptions): Extrinsic;\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex(): string;\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON(): string;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\nexport {};\r\n"}}
