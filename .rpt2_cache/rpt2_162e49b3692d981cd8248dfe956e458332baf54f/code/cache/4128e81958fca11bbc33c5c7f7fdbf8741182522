{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport BN from 'bn.js';\r\nimport { bnToBn, hexToBn, isHex, isString, isU8a, u8aToBn } from '@polkadot/util';\r\nimport { blake2AsU8a } from '@polkadot/util-crypto';\r\nimport U8a from './U8a';\r\nexport const DEFAULT_UINT_BITS = 64;\r\n/**\r\n * @name AbstractInt\r\n * @ignore\r\n * @noInheritDoc\r\n */\r\n// TODO:\r\n//   - Apart from encoding/decoding we don't actually keep check on the sizes, is this good enough?\r\nexport default class AbstractInt extends BN {\r\n    constructor(isNegative, value = 0, bitLength = DEFAULT_UINT_BITS, isHexJson = true) {\r\n        super(AbstractInt.decodeAbstracInt(value, bitLength, isNegative));\r\n        this._bitLength = bitLength;\r\n        this._isHexJson = isHexJson;\r\n        this._isNegative = isNegative;\r\n    }\r\n    static decodeAbstracInt(value, bitLength, isNegative) {\r\n        // This function returns a string, which will be passed in the BN\r\n        // constructor. It would be ideal to actually return a BN, but there's a\r\n        // bug: https://github.com/indutny/bn.js/issues/206.\r\n        if (isHex(value)) {\r\n            return hexToBn(value, { isLe: false, isNegative }).toString();\r\n        }\r\n        else if (isU8a(value)) {\r\n            if (!value.length) {\r\n                return '0';\r\n            }\r\n            try {\r\n                // NOTE When passing u8a in (typically from decoded data), it is always Little Endian\r\n                return u8aToBn(value.subarray(0, bitLength / 8), { isLe: true, isNegative }).toString();\r\n            }\r\n            catch (error) {\r\n                throw new Error(`AbstractInt: failed on ${JSON.stringify(value)}:: ${error.message}`);\r\n            }\r\n        }\r\n        else if (isString(value)) {\r\n            return new BN(value, 10).toString();\r\n        }\r\n        return bnToBn(value).toString();\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        return this._bitLength / 8;\r\n    }\r\n    /**\r\n     * @description returns a hash of the contents\r\n     */\r\n    get hash() {\r\n        return new U8a(blake2AsU8a(this.toU8a(), 256));\r\n    }\r\n    /**\r\n     * @description Checks if the value is a zero value (align elsewhere)\r\n     */\r\n    get isEmpty() {\r\n        return this.isZero();\r\n    }\r\n    /**\r\n     * @description Returns the number of bits in the value\r\n     */\r\n    bitLength() {\r\n        return this._bitLength;\r\n    }\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    eq(other) {\r\n        // Here we are actually overriding the built-in .eq to take care of both\r\n        // number and BN inputs (no `.eqn` needed) - numbers will be converted\r\n        return super.eq(isHex(other)\r\n            ? hexToBn(other.toString(), { isLe: false, isNegative: this._isNegative })\r\n            : bnToBn(other));\r\n    }\r\n    /**\r\n     * @description Returns the BN representation of the number. (Compatibility)\r\n     */\r\n    toBn() {\r\n        return this;\r\n    }\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON() {\r\n        // FIXME this return type should by string | number, but BN's return type\r\n        // is string.\r\n        // Maximum allowed integer for JS is 2^53 - 1, set limit at 52\r\n        return this._isHexJson || (super.bitLength() > 52)\r\n            ? this.toHex()\r\n            : this.toNumber();\r\n    }\r\n    /**\r\n     * @description Returns the string representation of the value\r\n     * @param base The base to use for the conversion\r\n     */\r\n    toString(base) {\r\n        // only included here since we do not inherit docs\r\n        return super.toString(base);\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/bn.js/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util-crypto/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/U8a.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/codec/AbstractInt.d.ts","writeByteOrderMark":false,"text":"import { AnyNumber, Codec, IHash } from '../types';\r\nimport BN from 'bn.js';\r\nexport declare type UIntBitLength = 8 | 16 | 32 | 64 | 128 | 256;\r\nexport declare const DEFAULT_UINT_BITS = 64;\r\n/**\r\n * @name AbstractInt\r\n * @ignore\r\n * @noInheritDoc\r\n */\r\nexport default abstract class AbstractInt extends BN implements Codec {\r\n    protected _bitLength: UIntBitLength;\r\n    private _isHexJson;\r\n    private _isNegative;\r\n    constructor(isNegative: boolean, value?: AnyNumber, bitLength?: UIntBitLength, isHexJson?: boolean);\r\n    static decodeAbstracInt(value: AnyNumber, bitLength: UIntBitLength, isNegative: boolean): string;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description returns a hash of the contents\r\n     */\r\n    readonly hash: IHash;\r\n    /**\r\n     * @description Checks if the value is a zero value (align elsewhere)\r\n     */\r\n    readonly isEmpty: boolean;\r\n    /**\r\n     * @description Returns the number of bits in the value\r\n     */\r\n    bitLength(): UIntBitLength;\r\n    /**\r\n     * @description Compares the value of the input to see if there is a match\r\n     */\r\n    eq(other?: any): boolean;\r\n    /**\r\n     * @description Returns the BN representation of the number. (Compatibility)\r\n     */\r\n    toBn(): BN;\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    abstract toHex(): string;\r\n    /**\r\n     * @description Converts the Object to JSON, typically used for RPC transfers\r\n     */\r\n    toJSON(): any;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    abstract toRawType(): string;\r\n    /**\r\n     * @description Returns the string representation of the value\r\n     * @param base The base to use for the conversion\r\n     */\r\n    toString(base?: number): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    abstract toU8a(isBare?: boolean): Uint8Array;\r\n}\r\n"}}
