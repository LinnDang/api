{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport createType from '../../../codec/createType';\r\nimport Struct from '../../../codec/Struct';\r\nimport ExtrinsicEra from '../ExtrinsicEra';\r\nimport { EMPTY_U8A, IMMORTAL_ERA } from '../constants';\r\nimport ExtrinsicPayload from './ExtrinsicPayload';\r\n/**\r\n * @name ExtrinsicSignature\r\n * @description\r\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\r\n */\r\nexport default class ExtrinsicSignatureV1 extends Struct {\r\n    // Signature Information.\r\n    //   1/3/5/9/33 bytes: The signing account identity, in Address format\r\n    //   64 bytes: The sr25519/ed25519 signature of the Signing Payload\r\n    //   1-8 bytes: The Compact<Nonce> of the signing account\r\n    //   1/2 bytes: The Transaction Era\r\n    constructor(value, { isSigned } = {}) {\r\n        super({\r\n            signer: 'Address',\r\n            signature: 'Signature',\r\n            nonce: 'Compact<Index>',\r\n            era: ExtrinsicEra\r\n        }, ExtrinsicSignatureV1.decodeExtrinsicSignature(value, isSigned));\r\n    }\r\n    static decodeExtrinsicSignature(value, isSigned = false) {\r\n        if (!value) {\r\n            return EMPTY_U8A;\r\n        }\r\n        else if (value instanceof ExtrinsicSignatureV1) {\r\n            return value;\r\n        }\r\n        return isSigned\r\n            ? value\r\n            : EMPTY_U8A;\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        return this.isSigned\r\n            ? super.encodedLength\r\n            : 0;\r\n    }\r\n    /**\r\n     * @description `true` if the signature is valid\r\n     */\r\n    get isSigned() {\r\n        return !this.signature.isEmpty;\r\n    }\r\n    /**\r\n     * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\r\n     */\r\n    get era() {\r\n        return this.get('era');\r\n    }\r\n    /**\r\n     * @description The [[Index]] for the signature\r\n     */\r\n    get nonce() {\r\n        return this.get('nonce');\r\n    }\r\n    /**\r\n     * @description The actuall [[Signature]] hash\r\n     */\r\n    get signature() {\r\n        return this.get('signature');\r\n    }\r\n    /**\r\n     * @description The [[Address]] that signed\r\n     */\r\n    get signer() {\r\n        return this.get('signer');\r\n    }\r\n    /**\r\n     * @description Forwards compat\r\n     */\r\n    get tip() {\r\n        return createType('Compact<Balance>', 0);\r\n    }\r\n    injectSignature(signer, signature, { era, nonce }) {\r\n        this.set('era', era);\r\n        this.set('nonce', nonce);\r\n        this.set('signer', signer);\r\n        this.set('signature', signature);\r\n        return this;\r\n    }\r\n    /**\r\n     * @description Adds a raw signature\r\n     */\r\n    addSignature(signer, signature, payload) {\r\n        return this.injectSignature(createType('Address', signer), createType('Signature', signature), new ExtrinsicPayload(payload));\r\n    }\r\n    /**\r\n     * @description Generate a payload and pplies the signature from a keypair\r\n     */\r\n    sign(method, account, { blockHash, era, genesisHash, nonce }) {\r\n        const signer = createType('Address', account.publicKey);\r\n        const payload = new ExtrinsicPayload({\r\n            blockHash,\r\n            era: era || IMMORTAL_ERA,\r\n            genesisHash,\r\n            method: method.toU8a(),\r\n            nonce,\r\n            tip: 0\r\n        });\r\n        const signature = createType('Signature', payload.sign(account));\r\n        return this.injectSignature(signer, signature, payload);\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        return this.isSigned\r\n            ? super.toU8a(isBare)\r\n            : EMPTY_U8A;\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/runtime/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/createType.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Compact.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Struct.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Generic/Call.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/ExtrinsicEra.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/constants.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Extrinsic/v1/ExtrinsicPayload.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Extrinsic/v1/ExtrinsicSignature.d.ts","writeByteOrderMark":false,"text":"import { Address, Balance, Index, Signature } from '../../../interfaces/runtime';\r\nimport { ExtrinsicPayloadValue, IExtrinsicSignature, IKeyringPair, SignatureOptions } from '../../../types';\r\nimport { ExtrinsicSignatureOptions } from '../types';\r\nimport Compact from '../../../codec/Compact';\r\nimport Struct from '../../../codec/Struct';\r\nimport Call from '../../Generic/Call';\r\nimport ExtrinsicEra from '../ExtrinsicEra';\r\n/**\r\n * @name ExtrinsicSignature\r\n * @description\r\n * A container for the [[Signature]] associated with a specific [[Extrinsic]]\r\n */\r\nexport default class ExtrinsicSignatureV1 extends Struct implements IExtrinsicSignature {\r\n    constructor(value?: ExtrinsicSignatureV1 | Uint8Array, { isSigned }?: ExtrinsicSignatureOptions);\r\n    static decodeExtrinsicSignature(value: ExtrinsicSignatureV1 | Uint8Array | undefined, isSigned?: boolean): ExtrinsicSignatureV1 | Uint8Array;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description `true` if the signature is valid\r\n     */\r\n    readonly isSigned: boolean;\r\n    /**\r\n     * @description The [[ExtrinsicEra]] (mortal or immortal) this signature applies to\r\n     */\r\n    readonly era: ExtrinsicEra;\r\n    /**\r\n     * @description The [[Index]] for the signature\r\n     */\r\n    readonly nonce: Compact<Index>;\r\n    /**\r\n     * @description The actuall [[Signature]] hash\r\n     */\r\n    readonly signature: Signature;\r\n    /**\r\n     * @description The [[Address]] that signed\r\n     */\r\n    readonly signer: Address;\r\n    /**\r\n     * @description Forwards compat\r\n     */\r\n    readonly tip: Compact<Balance>;\r\n    private injectSignature;\r\n    /**\r\n     * @description Adds a raw signature\r\n     */\r\n    addSignature(signer: Address | Uint8Array | string, signature: Uint8Array | string, payload: ExtrinsicPayloadValue | Uint8Array | string): IExtrinsicSignature;\r\n    /**\r\n     * @description Generate a payload and pplies the signature from a keypair\r\n     */\r\n    sign(method: Call, account: IKeyringPair, { blockHash, era, genesisHash, nonce }: SignatureOptions): IExtrinsicSignature;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\n"}}
