{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { assert, isString, isU8a, u8aToU8a } from '@polkadot/util';\r\nimport { ClassOf } from '../codec/createType';\r\nimport Compact from '../codec/Compact';\r\nimport U8a from '../codec/U8a';\r\n/**\r\n * @name Bytes\r\n * @description\r\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\r\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\r\n * as what is found in [[Text]] and [[Vec]])\r\n */\r\nexport default class Bytes extends U8a {\r\n    constructor(value) {\r\n        super(Bytes.decodeBytes(value));\r\n    }\r\n    static decodeBytes(value) {\r\n        if (Array.isArray(value) || isString(value)) {\r\n            const u8a = u8aToU8a(value);\r\n            return Bytes.decodeBytes(Compact.addLengthPrefix(u8a));\r\n        }\r\n        else if (value instanceof ClassOf('StorageData')) {\r\n            // Here we cater for the actual StorageData that _could_ have a length prefix. In the\r\n            // case of `:code` it is not added, for others it is\r\n            const u8a = value;\r\n            const [offset, length] = Compact.decodeU8a(u8a);\r\n            return u8a.length === length.addn(offset).toNumber()\r\n                ? u8a.subarray(offset)\r\n                : u8a;\r\n        }\r\n        else if (value instanceof U8a) {\r\n            // This is required. In the case of a U8a we already have gotten rid of the length,\r\n            // i.e. new Bytes(new Bytes(...)) will work as expected\r\n            return value;\r\n        }\r\n        else if (isU8a(value)) {\r\n            if (!value.length) {\r\n                return new Uint8Array();\r\n            }\r\n            // handle all other Uint8Array inputs, these do have a length prefix\r\n            const [offset, length] = Compact.decodeU8a(value);\r\n            const total = offset + length.toNumber();\r\n            assert(total <= value.length, `Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);\r\n            return value.subarray(offset, total);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        return this.length + Compact.encodeU8a(this.length).length;\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return 'Bytes';\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        return isBare\r\n            ? super.toU8a(isBare)\r\n            : Compact.addLengthPrefix(this);\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/createType.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Compact.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/U8a.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Bytes.d.ts","writeByteOrderMark":false,"text":"import { AnyU8a } from '../types';\r\nimport U8a from '../codec/U8a';\r\n/**\r\n * @name Bytes\r\n * @description\r\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\r\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\r\n * as what is found in [[Text]] and [[Vec]])\r\n */\r\nexport default class Bytes extends U8a {\r\n    constructor(value?: AnyU8a);\r\n    private static decodeBytes;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\n"}}
