{"code":"/* eslint-disable @typescript-eslint/camelcase */\r\n// Copyright 2017-2019 @polkadot/rpc-provider authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport './polyfill';\r\nimport EventEmitter from 'eventemitter3';\r\nimport { assert, isNull, isUndefined, logger } from '@polkadot/util';\r\nimport Coder from '../coder';\r\nimport defaults from '../defaults';\r\nconst ALIASSES = {\r\n    chain_finalisedHead: 'chain_finalizedHead',\r\n    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\r\n    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\r\n};\r\nconst l = logger('api-ws');\r\n/**\r\n * # @polkadot/rpc-provider/ws\r\n *\r\n * @name WsProvider\r\n *\r\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\r\n *\r\n * @example\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import Api from '@polkadot/api/promise';\r\n * import WsProvider from '@polkadot/rpc-provider/ws';\r\n *\r\n * const provider = new WsProvider('ws://127.0.0.1:9944');\r\n * const api = new Api(provider);\r\n * ```\r\n *\r\n * @see [[HttpProvider]]\r\n */\r\nexport default class WsProvider {\r\n    /**\r\n     * @param {string}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`\r\n     * @param {boolean} autoConnect Whether to connect automatically or not.\r\n     */\r\n    constructor(endpoint = defaults.WS_URL, autoConnect = true) {\r\n        this._isConnected = false;\r\n        this.onSocketClose = (event) => {\r\n            if (this.autoConnect) {\r\n                l.error(`disconnected from ${this.endpoint} code: '${event.code}' reason: '${event.reason}'`);\r\n            }\r\n            this._isConnected = false;\r\n            this.emit('disconnected');\r\n            if (this.autoConnect) {\r\n                setTimeout(() => {\r\n                    this.connect();\r\n                }, 1000);\r\n            }\r\n        };\r\n        this.onSocketError = (error) => {\r\n            l.debug(() => ['socket error', error]);\r\n            this.emit('error', error);\r\n        };\r\n        this.onSocketMessage = (message) => {\r\n            l.debug(() => ['received', message.data]);\r\n            const response = JSON.parse(message.data);\r\n            return isUndefined(response.method)\r\n                ? this.onSocketMessageResult(response)\r\n                : this.onSocketMessageSubscribe(response);\r\n        };\r\n        this.onSocketMessageResult = (response) => {\r\n            const handler = this.handlers[response.id];\r\n            if (!handler) {\r\n                l.debug(() => `Unable to find handler for id=${response.id}`);\r\n                return;\r\n            }\r\n            try {\r\n                const { method, params, subscription } = handler;\r\n                const result = this.coder.decodeResponse(response);\r\n                // first send the result - in case of subs, we may have an update\r\n                // immediately if we have some queued results already\r\n                handler.callback(null, result);\r\n                if (subscription) {\r\n                    const subId = `${subscription.type}::${result}`;\r\n                    this.subscriptions[subId] = {\r\n                        ...subscription,\r\n                        method,\r\n                        params\r\n                    };\r\n                    // if we have a result waiting for this subscription already\r\n                    if (this.waitingForId[subId]) {\r\n                        this.onSocketMessageSubscribe(this.waitingForId[subId]);\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                handler.callback(error, undefined);\r\n            }\r\n            delete this.handlers[response.id];\r\n        };\r\n        this.onSocketMessageSubscribe = (response) => {\r\n            const method = ALIASSES[response.method] || response.method;\r\n            const subId = `${method}::${response.params.subscription}`;\r\n            const handler = this.subscriptions[subId];\r\n            if (!handler) {\r\n                // store the JSON, we could have out-of-order subid coming in\r\n                this.waitingForId[subId] = response;\r\n                l.debug(() => `Unable to find handler for subscription=${subId}`);\r\n                return;\r\n            }\r\n            // housekeeping\r\n            delete this.waitingForId[subId];\r\n            try {\r\n                const result = this.coder.decodeResponse(response);\r\n                handler.callback(null, result);\r\n            }\r\n            catch (error) {\r\n                handler.callback(error, undefined);\r\n            }\r\n        };\r\n        this.onSocketOpen = () => {\r\n            assert(!isNull(this.websocket), 'WebSocket cannot be null in onOpen');\r\n            l.debug(() => ['connected to', this.endpoint]);\r\n            this._isConnected = true;\r\n            this.emit('connected');\r\n            this.sendQueue();\r\n            this.resubscribe();\r\n            return true;\r\n        };\r\n        assert(/^(wss|ws):\\/\\//.test(endpoint), `Endpoint should start with 'ws://', received '${endpoint}'`);\r\n        this._eventemitter = new EventEmitter();\r\n        this.autoConnect = autoConnect;\r\n        this.coder = new Coder();\r\n        this.endpoint = endpoint;\r\n        this.handlers = {};\r\n        this.queued = {};\r\n        this.subscriptions = {};\r\n        this.waitingForId = {};\r\n        this.websocket = null;\r\n        if (autoConnect) {\r\n            this.connect();\r\n        }\r\n    }\r\n    /**\r\n     * @summary `true` when this provider supports subscriptions\r\n     */\r\n    get hasSubscriptions() {\r\n        return true;\r\n    }\r\n    /**\r\n     * @description Returns a clone of the object\r\n     */\r\n    clone() {\r\n        return new WsProvider(this.endpoint);\r\n    }\r\n    /**\r\n     * @summary Manually connect\r\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\r\n     * connect manually using this method.\r\n     */\r\n    connect() {\r\n        try {\r\n            this.websocket = new WebSocket(this.endpoint);\r\n            this.websocket.onclose = this.onSocketClose;\r\n            this.websocket.onerror = this.onSocketError;\r\n            this.websocket.onmessage = this.onSocketMessage;\r\n            this.websocket.onopen = this.onSocketOpen;\r\n        }\r\n        catch (error) {\r\n            l.error(error);\r\n        }\r\n    }\r\n    /**\r\n     * @description Manually disconnect from the connection, clearing autoconnect logic\r\n     */\r\n    disconnect() {\r\n        if (isNull(this.websocket)) {\r\n            throw new Error('Cannot disconnect on a non-open websocket');\r\n        }\r\n        // switch off autoConnect, we are in manual mode now\r\n        this.autoConnect = false;\r\n        // 1000 - Normal closure; the connection successfully completed\r\n        this.websocket.close(1000);\r\n        this.websocket = null;\r\n    }\r\n    /**\r\n     * @summary Whether the node is connected or not.\r\n     * @return {boolean} true if connected\r\n     */\r\n    isConnected() {\r\n        return this._isConnected;\r\n    }\r\n    /**\r\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\r\n     * @param  {ProviderInterfaceEmitted} type Event\r\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\r\n     */\r\n    on(type, sub) {\r\n        this._eventemitter.on(type, sub);\r\n    }\r\n    /**\r\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\r\n     * @param method The RPC methods to execute\r\n     * @param params Encoded paramaters as appliucable for the method\r\n     * @param subscription Subscription details (internally used)\r\n     */\r\n    send(method, params, subscription) {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                const json = this.coder.encodeJson(method, params);\r\n                const id = this.coder.getId();\r\n                const callback = (error, result) => {\r\n                    error\r\n                        ? reject(error)\r\n                        : resolve(result);\r\n                };\r\n                l.debug(() => ['calling', method, json]);\r\n                this.handlers[id] = {\r\n                    callback,\r\n                    method,\r\n                    params,\r\n                    subscription\r\n                };\r\n                if (this.isConnected() && !isNull(this.websocket)) {\r\n                    this.websocket.send(json);\r\n                }\r\n                else {\r\n                    this.queued[id] = json;\r\n                }\r\n            }\r\n            catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @name subscribe\r\n     * @summary Allows subscribing to a specific event.\r\n     * @param  {string}                     type     Subscription type\r\n     * @param  {string}                     method   Subscription method\r\n     * @param  {any[]}                 params   Parameters\r\n     * @param  {ProviderInterfaceCallback} callback Callback\r\n     * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\r\n     * const rpc = new Rpc(provider);\r\n     *\r\n     * rpc.state.subscribeStorage([[storage.balances.freeBalance, <Address>]], (_, values) => {\r\n     *   console.log(values)\r\n     * }).then((subscriptionId) => {\r\n     *   console.log('balance changes subscription id: ', subscriptionId)\r\n     * })\r\n     * ```\r\n     */\r\n    async subscribe(type, method, params, callback) {\r\n        const id = await this.send(method, params, { callback, type });\r\n        return id;\r\n    }\r\n    /**\r\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\r\n     */\r\n    async unsubscribe(type, method, id) {\r\n        const subscription = `${type}::${id}`;\r\n        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\r\n        // the assigned id now does not match what the API user originally received. It has\r\n        // a slight complication in solving - since we cannot rely on the send id, but rather\r\n        // need to find the actual subscription id to map it\r\n        if (isUndefined(this.subscriptions[subscription])) {\r\n            l.debug(() => `Unable to find active subscription=${subscription}`);\r\n            return false;\r\n        }\r\n        delete this.subscriptions[subscription];\r\n        const result = await this.send(method, [id]);\r\n        return result;\r\n    }\r\n    emit(type, ...args) {\r\n        this._eventemitter.emit(type, ...args);\r\n    }\r\n    resubscribe() {\r\n        const subscriptions = this.subscriptions;\r\n        this.subscriptions = {};\r\n        Object.keys(subscriptions).forEach(async (id) => {\r\n            const { callback, method, params, type } = subscriptions[id];\r\n            // only re-create subscriptions which are not in author (only area where\r\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\r\n            // are not included (and will not be re-broadcast)\r\n            if (type.startsWith('author_')) {\r\n                return;\r\n            }\r\n            try {\r\n                await this.subscribe(type, method, params, callback);\r\n            }\r\n            catch (error) {\r\n                l.error(error);\r\n            }\r\n        });\r\n    }\r\n    sendQueue() {\r\n        Object.keys(this.queued).forEach((id) => {\r\n            try {\r\n                // @ts-ignore we have done the websocket check in onSocketOpen, if an issue, will catch it\r\n                this.websocket.send(this.queued[id]);\r\n                delete this.queued[id];\r\n            }\r\n            catch (error) {\r\n                l.error(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/rpc-provider/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/rpc-provider/src/ws/polyfill.ts","/Users/jacogreeff/Projects/polkadot/api/packages/rpc-provider/node_modules/eventemitter3/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/rpc-provider/src/coder/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/rpc-provider/src/defaults.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/rpc-provider/src/ws/Provider.d.ts","writeByteOrderMark":false,"text":"import { ProviderInterface, ProviderInterfaceCallback, ProviderInterfaceEmitted, ProviderInterfaceEmitCb } from '../types';\r\nimport './polyfill';\r\ndeclare type CallbackHandler = (error?: null | Error, value?: any) => void;\r\ninterface SubscriptionHandler {\r\n    callback: CallbackHandler;\r\n    type: string;\r\n}\r\ninterface WSProviderInterface extends ProviderInterface {\r\n    connect(): void;\r\n}\r\n/**\r\n * # @polkadot/rpc-provider/ws\r\n *\r\n * @name WsProvider\r\n *\r\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\r\n *\r\n * @example\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import Api from '@polkadot/api/promise';\r\n * import WsProvider from '@polkadot/rpc-provider/ws';\r\n *\r\n * const provider = new WsProvider('ws://127.0.0.1:9944');\r\n * const api = new Api(provider);\r\n * ```\r\n *\r\n * @see [[HttpProvider]]\r\n */\r\nexport default class WsProvider implements WSProviderInterface {\r\n    private _eventemitter;\r\n    private _isConnected;\r\n    private autoConnect;\r\n    private coder;\r\n    private endpoint;\r\n    private handlers;\r\n    private queued;\r\n    private subscriptions;\r\n    private waitingForId;\r\n    private websocket;\r\n    /**\r\n     * @param {string}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`\r\n     * @param {boolean} autoConnect Whether to connect automatically or not.\r\n     */\r\n    constructor(endpoint?: string, autoConnect?: boolean);\r\n    /**\r\n     * @summary `true` when this provider supports subscriptions\r\n     */\r\n    readonly hasSubscriptions: boolean;\r\n    /**\r\n     * @description Returns a clone of the object\r\n     */\r\n    clone(): WsProvider;\r\n    /**\r\n     * @summary Manually connect\r\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\r\n     * connect manually using this method.\r\n     */\r\n    connect(): void;\r\n    /**\r\n     * @description Manually disconnect from the connection, clearing autoconnect logic\r\n     */\r\n    disconnect(): void;\r\n    /**\r\n     * @summary Whether the node is connected or not.\r\n     * @return {boolean} true if connected\r\n     */\r\n    isConnected(): boolean;\r\n    /**\r\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\r\n     * @param  {ProviderInterfaceEmitted} type Event\r\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\r\n     */\r\n    on(type: ProviderInterfaceEmitted, sub: ProviderInterfaceEmitCb): void;\r\n    /**\r\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\r\n     * @param method The RPC methods to execute\r\n     * @param params Encoded paramaters as appliucable for the method\r\n     * @param subscription Subscription details (internally used)\r\n     */\r\n    send(method: string, params: any[], subscription?: SubscriptionHandler): Promise<any>;\r\n    /**\r\n     * @name subscribe\r\n     * @summary Allows subscribing to a specific event.\r\n     * @param  {string}                     type     Subscription type\r\n     * @param  {string}                     method   Subscription method\r\n     * @param  {any[]}                 params   Parameters\r\n     * @param  {ProviderInterfaceCallback} callback Callback\r\n     * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\r\n     * const rpc = new Rpc(provider);\r\n     *\r\n     * rpc.state.subscribeStorage([[storage.balances.freeBalance, <Address>]], (_, values) => {\r\n     *   console.log(values)\r\n     * }).then((subscriptionId) => {\r\n     *   console.log('balance changes subscription id: ', subscriptionId)\r\n     * })\r\n     * ```\r\n     */\r\n    subscribe(type: string, method: string, params: any[], callback: ProviderInterfaceCallback): Promise<number>;\r\n    /**\r\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\r\n     */\r\n    unsubscribe(type: string, method: string, id: number): Promise<boolean>;\r\n    private emit;\r\n    private onSocketClose;\r\n    private onSocketError;\r\n    private onSocketMessage;\r\n    private onSocketMessageResult;\r\n    private onSocketMessageSubscribe;\r\n    private onSocketOpen;\r\n    private resubscribe;\r\n    private sendQueue;\r\n}\r\nexport {};\r\n"}}
