{"code":"// Copyright 2017-2019 @polkadot/rpc-core authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport memoizee from 'memoizee';\r\nimport { combineLatest, from, Observable, of, throwError } from 'rxjs';\r\nimport { catchError, map, publishReplay, refCount, switchMap } from 'rxjs/operators';\r\nimport interfaces from '@polkadot/jsonrpc';\r\nimport { ClassOf, Option, createClass } from '@polkadot/types';\r\nimport { createTypeUnsafe } from '@polkadot/types/codec/createType';\r\nimport { ExtError, assert, isFunction, isNull, isNumber, logger } from '@polkadot/util';\r\nconst l = logger('rpc-core');\r\nconst EMPTY_META = {\r\n    fallback: undefined,\r\n    modifier: { isOptional: true },\r\n    type: {\r\n        asMap: { isLinked: false },\r\n        isMap: false\r\n    }\r\n};\r\n/**\r\n * @name Rpc\r\n * @summary The API may use a HTTP or WebSockets provider.\r\n * @description It allows for querying a Polkadot Client Node.\r\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\r\n *\r\n * ```mermaid\r\n * graph LR;\r\n *   A[Api] --> |WebSockets| B[WsProvider];\r\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\r\n * ```\r\n *\r\n * @example\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import Rpc from '@polkadot/rpc-core';\r\n * import WsProvider from '@polkadot/rpc-provider/ws';\r\n *\r\n * const provider = new WsProvider('ws://127.0.0.1:9944');\r\n * const rpc = new Rpc(provider);\r\n * ```\r\n */\r\nexport default class Rpc {\r\n    /**\r\n     * @constructor\r\n     * Default constructor for the Api Object\r\n     * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\r\n     */\r\n    constructor(provider) {\r\n        this._storageCache = new Map();\r\n        assert(provider && isFunction(provider.send), 'Expected Provider to API create');\r\n        this.provider = provider;\r\n        this.author = this.createInterface('author');\r\n        this.chain = this.createInterface('chain');\r\n        this.state = this.createInterface('state');\r\n        this.system = this.createInterface('system');\r\n    }\r\n    /**\r\n     * @name signature\r\n     * @summary Returns a string representation of the method with inputs and outputs.\r\n     * @description\r\n     * Formats the name, inputs and outputs into a human-readable string. This contains the input parameter names input types and output type.\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import Api from '@polkadot/rpc-core';\r\n     *\r\n     * Api.signature({ name: 'test_method', params: [ { name: 'dest', type: 'Address' } ], type: 'Address' }); // => test_method (dest: Address): Address\r\n     * ```\r\n     */\r\n    static signature({ method, params, type }) {\r\n        const inputs = params.map(({ name, type }) => `${name}: ${type}`).join(', ');\r\n        return `${method} (${inputs}): ${type}`;\r\n    }\r\n    /**\r\n     * @description Manually disconnect from the attached provider\r\n     */\r\n    disconnect() {\r\n        this.provider.disconnect();\r\n    }\r\n    createErrorMessage(method, error) {\r\n        return `${Rpc.signature(method)}:: ${error.message}`;\r\n    }\r\n    createInterface(section) {\r\n        const { methods } = interfaces[section];\r\n        return Object\r\n            .keys(methods)\r\n            .reduce((exposed, methodName) => {\r\n            const def = methods[methodName];\r\n            // FIXME Remove any here\r\n            // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\r\n            // every method inside this class to take:\r\n            // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\r\n            // Not doing so, because it makes this class a little bit less readable,\r\n            // and leaving it as-is doesn't harm much\r\n            exposed[methodName] = def.isSubscription\r\n                ? this.createMethodSubscribe(def)\r\n                : this.createMethodSend(def);\r\n            return exposed;\r\n        }, {});\r\n    }\r\n    createMethodSend(method) {\r\n        const rpcName = `${method.section}_${method.method}`;\r\n        const call = (...values) => {\r\n            // TODO Warn on deprecated methods\r\n            // Here, logically, it should be `of(this.formatInputs(method, values))`.\r\n            // However, formatInputs can throw, and when it does, the above way\r\n            // doesn't throw in the \"Observable loop\" (which is internally wrapped in\r\n            // a try/catch block). So we:\r\n            // - first do `of(1)` - won't throw\r\n            // - then do `map(()=>this.formatInputs)` - might throw, but inside Observable.\r\n            return of(1)\r\n                .pipe(map(() => this.formatInputs(method, values)), switchMap((params) => combineLatest([\r\n                of(params),\r\n                from(this.provider.send(rpcName, params.map((param) => param.toJSON())))\r\n            ])), map(([params, result]) => this.formatOutput(method, params, result)), catchError((error) => {\r\n                const message = this.createErrorMessage(method, error);\r\n                l.error(message);\r\n                return throwError(new ExtError(message, error.code, undefined));\r\n            }), publishReplay(1), // create a Replay(1)\r\n            refCount() // Unsubcribe WS when there are no more subscribers\r\n            );\r\n        };\r\n        // We voluntarily don't cache the \"one-shot\" RPC calls. For example,\r\n        // `getStorage('123')` returns the current value, but this value can change\r\n        // over time, so we wouldn't want to cache the Observable.\r\n        return call;\r\n    }\r\n    createMethodSubscribe(method) {\r\n        const [updateType, subMethod, unsubMethod] = method.pubsub;\r\n        const subName = `${method.section}_${subMethod}`;\r\n        const unsubName = `${method.section}_${unsubMethod}`;\r\n        const subType = `${method.section}_${updateType}`;\r\n        const call = (...values) => {\r\n            return new Observable((observer) => {\r\n                // Have at least an empty promise, as used in the unsubscribe\r\n                let subscriptionPromise = Promise.resolve();\r\n                const errorHandler = (error) => {\r\n                    const message = this.createErrorMessage(method, error);\r\n                    l.error(message);\r\n                    observer.error(new ExtError(message, error.code, undefined));\r\n                };\r\n                try {\r\n                    const params = this.formatInputs(method, values);\r\n                    const paramsJson = params.map((param) => param.toJSON());\r\n                    const update = (error, result) => {\r\n                        if (error) {\r\n                            l.error(this.createErrorMessage(method, error));\r\n                            return;\r\n                        }\r\n                        observer.next(this.formatOutput(method, params, result));\r\n                    };\r\n                    subscriptionPromise = this.provider\r\n                        .subscribe(subType, subName, paramsJson, update)\r\n                        .catch(errorHandler);\r\n                }\r\n                catch (error) {\r\n                    errorHandler(error);\r\n                }\r\n                // Teardown logic\r\n                return () => {\r\n                    // Delete from cache\r\n                    // Reason:\r\n                    // ```\r\n                    //    const s = api.query.system.accountNonce(addr1).subscribe(); // let's say it's 6\r\n                    //    s.unsubscribe();\r\n                    //    // wait a bit, for the nonce to increase to 7\r\n                    //    api.query.system.accountNonce(addr1).subscribe(); // will output 6 instead of 7 if we don't clear cache\r\n                    //    // that's because all our observables are replay(1)\r\n                    // ```\r\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n                    memoized.delete(...values);\r\n                    // Unsubscribe from provider\r\n                    subscriptionPromise\r\n                        .then((subscriptionId) => isNumber(subscriptionId)\r\n                        ? this.provider.unsubscribe(subType, unsubName, subscriptionId)\r\n                        : Promise.resolve(false))\r\n                        .catch((error) => {\r\n                        const message = this.createErrorMessage(method, error);\r\n                        l.error(message);\r\n                    });\r\n                };\r\n            }).pipe(publishReplay(1), refCount());\r\n        };\r\n        const memoized = memoizee(call, {\r\n            // Dynamic length for argument\r\n            length: false,\r\n            // Normalize args so that different args that should be cached\r\n            // together are cached together.\r\n            // E.g.: `query.my.method('abc') === query.my.method(createType('AccountId', 'abc'));`\r\n            normalizer: JSON.stringify\r\n        });\r\n        return memoized;\r\n    }\r\n    formatInputs(method, inputs) {\r\n        const reqArgCount = method.params.filter(({ isOptional }) => !isOptional).length;\r\n        const optText = reqArgCount === method.params.length\r\n            ? ''\r\n            : ` (${method.params.length - reqArgCount} optional)`;\r\n        assert(inputs.length >= reqArgCount && inputs.length <= method.params.length, `Expected ${method.params.length} parameters${optText}, ${inputs.length} found instead`);\r\n        return inputs.map((input, index) => createTypeUnsafe(method.params[index].type, [input]));\r\n    }\r\n    formatOutput(method, params, result) {\r\n        const base = createTypeUnsafe(method.type, [result]);\r\n        if (method.type === 'StorageData') {\r\n            const key = params[0];\r\n            try {\r\n                return this.formatStorageData(key, base, isNull(result));\r\n            }\r\n            catch (error) {\r\n                console.error(`Unable to decode storage ${key.section}.${key.method}:`, error.message);\r\n                throw error;\r\n            }\r\n        }\r\n        else if (method.type === 'StorageChangeSet') {\r\n            const keys = params[0];\r\n            const withCache = keys.length !== 1;\r\n            // multiple return values (via state.storage subscription), decode the values\r\n            // one at a time, all based on the query types. Three values can be returned -\r\n            //   - Base - There is a valid value, non-empty\r\n            //   - null - The storage key is empty (but in the resultset)\r\n            //   - undefined - The storage value is not in the resultset\r\n            return keys.reduce((results, key) => {\r\n                try {\r\n                    results.push(this.formatStorageSet(key, base, withCache));\r\n                }\r\n                catch (error) {\r\n                    console.error(`Unable to decode storage ${key.section}.${key.method}:`, error.message);\r\n                    throw error;\r\n                }\r\n                return results;\r\n            }, []);\r\n        }\r\n        return base;\r\n    }\r\n    formatStorageData(key, base, isNull) {\r\n        // single return value (via state.getStorage), decode the value based on the\r\n        // outputType that we have specified. Fallback to Data on nothing\r\n        const type = key.outputType || 'Data';\r\n        const meta = key.meta || EMPTY_META;\r\n        if (meta.modifier.isOptional) {\r\n            return new Option(createClass(type), isNull ? null : createTypeUnsafe(type, [base], true));\r\n        }\r\n        return createTypeUnsafe(type, [isNull ? meta.fallback : base], true);\r\n    }\r\n    formatStorageSet(key, base, witCache) {\r\n        // Fallback to Data (i.e. just the encoding) if we don't have a specific type\r\n        const type = key.outputType || 'Data';\r\n        const hexKey = key.toHex();\r\n        const meta = key.meta || EMPTY_META;\r\n        // if we don't find the value, this is out fallback\r\n        //   - in the case of an array of values, fill the hole from the cache\r\n        //   - if a single result value, don't fill - it is not an update hole\r\n        //   - fallback to an empty option in all cases\r\n        const emptyVal = (witCache\r\n            ? this._storageCache.get(hexKey)\r\n            : null) || new Option(ClassOf('StorageData'), null);\r\n        // see if we have a result value for this specific key, fallback to the cache value\r\n        // when the value in the set is not available, or is null/empty.\r\n        const [, value] = base.changes.find(([key, value]) => value.isSome && key.toHex() === hexKey) || [null, emptyVal];\r\n        // store the retrieved result - the only issue with this cache is that there is no\r\n        // clearning of it, so very long running processes (not just a couple of hours, longer)\r\n        // will increase memory beyond what is allowed.\r\n        this._storageCache.set(hexKey, value);\r\n        if (meta.modifier.isOptional) {\r\n            return new Option(createClass(type), value.isNone ? null : createTypeUnsafe(type, [value.unwrap()], true));\r\n        }\r\n        return createTypeUnsafe(type, [value.unwrapOr(meta.fallback)], true);\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/rpc-provider/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/type-jsonrpc/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaces/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/rpc-core/src/jsonrpc.types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/rpc-core/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/memoizee/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/operators/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/type-jsonrpc/src/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/index.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/createType.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/rpc-core/src/index.d.ts","writeByteOrderMark":false,"text":"import { ProviderInterface } from '@polkadot/rpc-provider/types';\r\nimport { RpcMethod } from '@polkadot/jsonrpc/types';\r\nimport { RpcInterface } from './jsonrpc.types';\r\n/**\r\n * @name Rpc\r\n * @summary The API may use a HTTP or WebSockets provider.\r\n * @description It allows for querying a Polkadot Client Node.\r\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\r\n *\r\n * ```mermaid\r\n * graph LR;\r\n *   A[Api] --> |WebSockets| B[WsProvider];\r\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\r\n * ```\r\n *\r\n * @example\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import Rpc from '@polkadot/rpc-core';\r\n * import WsProvider from '@polkadot/rpc-provider/ws';\r\n *\r\n * const provider = new WsProvider('ws://127.0.0.1:9944');\r\n * const rpc = new Rpc(provider);\r\n * ```\r\n */\r\nexport default class Rpc implements RpcInterface {\r\n    private _storageCache;\r\n    readonly provider: ProviderInterface;\r\n    readonly author: RpcInterface['author'];\r\n    readonly chain: RpcInterface['chain'];\r\n    readonly state: RpcInterface['state'];\r\n    readonly system: RpcInterface['system'];\r\n    /**\r\n     * @constructor\r\n     * Default constructor for the Api Object\r\n     * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\r\n     */\r\n    constructor(provider: ProviderInterface);\r\n    /**\r\n     * @name signature\r\n     * @summary Returns a string representation of the method with inputs and outputs.\r\n     * @description\r\n     * Formats the name, inputs and outputs into a human-readable string. This contains the input parameter names input types and output type.\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import Api from '@polkadot/rpc-core';\r\n     *\r\n     * Api.signature({ name: 'test_method', params: [ { name: 'dest', type: 'Address' } ], type: 'Address' }); // => test_method (dest: Address): Address\r\n     * ```\r\n     */\r\n    static signature({ method, params, type }: RpcMethod): string;\r\n    /**\r\n     * @description Manually disconnect from the attached provider\r\n     */\r\n    disconnect(): void;\r\n    private createErrorMessage;\r\n    private createInterface;\r\n    private createMethodSend;\r\n    private createMethodSubscribe;\r\n    private formatInputs;\r\n    private formatOutput;\r\n    private formatStorageData;\r\n    private formatStorageSet;\r\n}\r\n"}}
