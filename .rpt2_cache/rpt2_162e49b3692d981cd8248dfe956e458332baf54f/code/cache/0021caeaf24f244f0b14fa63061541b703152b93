{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { TypeDefInfo } from './types';\r\nimport { assert } from '@polkadot/util';\r\nimport Compact from './Compact';\r\nimport Enum from './Enum';\r\nimport Linkage from './Linkage';\r\nimport Option from './Option';\r\nimport CodecSet from './Set';\r\nimport Struct from './Struct';\r\nimport Tuple from './Tuple';\r\nimport U8aFixed from './U8aFixed';\r\nimport Vec from './Vec';\r\nimport VecFixed from './VecFixed';\r\nimport getTypeRegistry from './typeRegistry';\r\n// safely split a string on ', ' while taking care of any nested occurences\r\nexport function typeSplit(type) {\r\n    let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];\r\n    const result = [];\r\n    for (let index = 0; index < type.length; index++) {\r\n        switch (type[index]) {\r\n            case ',':\r\n                // we are not nested, add the type\r\n                if (cDepth === 0 && fDepth === 0 && sDepth === 0 && tDepth === 0) {\r\n                    result.push(type.substr(start, index - start).trim());\r\n                    start = index + 1;\r\n                }\r\n                break;\r\n            // adjust compact/vec (and friends) depth\r\n            case '<':\r\n                cDepth++;\r\n                break;\r\n            case '>':\r\n                cDepth--;\r\n                break;\r\n            // adjust fixed vec depths\r\n            case '[':\r\n                fDepth++;\r\n                break;\r\n            case ']':\r\n                fDepth--;\r\n                break;\r\n            // adjust struct depth\r\n            case '{':\r\n                sDepth++;\r\n                break;\r\n            case '}':\r\n                sDepth--;\r\n                break;\r\n            // adjust tuple depth\r\n            case '(':\r\n                tDepth++;\r\n                break;\r\n            case ')':\r\n                tDepth--;\r\n                break;\r\n        }\r\n    }\r\n    assert(!cDepth && !fDepth && !sDepth && !tDepth, `Invalid defintion (missing terminators) found in ${type}`);\r\n    // the final leg of the journey\r\n    result.push(type.substr(start, type.length - start).trim());\r\n    return result;\r\n}\r\n// decode an enum of either of the following forms\r\n//  { _enum: ['A', 'B', 'C'] }\r\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\r\nfunction _decodeEnum(value, details) {\r\n    value.info = TypeDefInfo.Enum;\r\n    // not as pretty, but remain compatible with oo7 for both struct and Array types\r\n    value.sub = Array.isArray(details)\r\n        ? details.map((name) => ({\r\n            info: TypeDefInfo.Plain,\r\n            name,\r\n            type: 'Null'\r\n        }))\r\n        : Object.entries(details).map(([name, type]) => \r\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n        getTypeDef(type || 'Null', name));\r\n    return value;\r\n}\r\n// decode a set of the form\r\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\r\nfunction _decodeSet(value, details) {\r\n    value.info = TypeDefInfo.Set;\r\n    value.sub = Object.entries(details).map(([name, index]) => ({\r\n        index,\r\n        info: TypeDefInfo.Plain,\r\n        name,\r\n        type: name\r\n    }));\r\n    return value;\r\n}\r\nexport function getTypeDef(_type, name) {\r\n    const type = _type.toString().trim();\r\n    const value = {\r\n        info: TypeDefInfo.Plain,\r\n        name,\r\n        type\r\n    };\r\n    let subType = '';\r\n    const startingWith = (type, start, end) => {\r\n        if (type.substr(0, start.length) !== start) {\r\n            return false;\r\n        }\r\n        assert(type[type.length - 1] === end, `Expected '${start}' closing with '${end}'`);\r\n        subType = type.substr(start.length, type.length - start.length - 1);\r\n        return true;\r\n    };\r\n    if (startingWith(type, '(', ')')) {\r\n        value.info = TypeDefInfo.Tuple;\r\n        value.sub = typeSplit(subType).map((inner) => getTypeDef(inner));\r\n    }\r\n    else if (startingWith(type, '[', ']')) {\r\n        // this handles e.g. [u8;32]\r\n        const [vecType, _vecLen] = type.substr(1, type.length - 2).split(';');\r\n        const vecLen = parseInt(_vecLen.trim(), 10);\r\n        // as a first round, only u8 via u8aFixed, we can add more support\r\n        assert(vecLen <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);\r\n        value.info = TypeDefInfo.VecFixed;\r\n        value.ext = { length: vecLen, type: vecType };\r\n    }\r\n    else if (startingWith(type, '{', '}')) {\r\n        const parsed = JSON.parse(type);\r\n        const keys = Object.keys(parsed);\r\n        if (keys.length === 1 && keys[0] === '_enum') {\r\n            _decodeEnum(value, parsed[keys[0]]);\r\n        }\r\n        else if (keys.length === 1 && keys[0] === '_set') {\r\n            _decodeSet(value, parsed[keys[0]]);\r\n        }\r\n        else {\r\n            value.info = TypeDefInfo.Struct;\r\n            value.sub = keys.map((name) => getTypeDef(parsed[name], name));\r\n        }\r\n    }\r\n    else if (startingWith(type, 'Compact<', '>')) {\r\n        value.info = TypeDefInfo.Compact;\r\n        value.sub = getTypeDef(subType);\r\n    }\r\n    else if (startingWith(type, 'Option<', '>')) {\r\n        value.info = TypeDefInfo.Option;\r\n        value.sub = getTypeDef(subType);\r\n    }\r\n    else if (startingWith(type, 'Vec<', '>')) {\r\n        value.info = TypeDefInfo.Vec;\r\n        value.sub = getTypeDef(subType);\r\n    }\r\n    else if (startingWith(type, 'Linkage<', '>')) {\r\n        value.info = TypeDefInfo.Linkage;\r\n        value.sub = getTypeDef(subType);\r\n    }\r\n    else if (startingWith(type, 'DoubleMap<', '>')) {\r\n        value.info = TypeDefInfo.DoubleMap;\r\n        value.sub = getTypeDef(subType);\r\n    }\r\n    return value;\r\n}\r\nexport function createClass(type) {\r\n    // return memoizedCreateClass(type);\r\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n    return getTypeClass(getTypeDef(type));\r\n}\r\n// An unsafe version of the `createType` below. It's unsafe because the `type`\r\n// argument here can be any string, which, if not parseable, will yield a\r\n// runtime error.\r\nexport function ClassOfUnsafe(name) {\r\n    return createClass(name);\r\n}\r\n// alias for createClass\r\nexport function ClassOf(name) {\r\n    return ClassOfUnsafe(name);\r\n}\r\n// create a maps of type string constructors from the input\r\nexport function getTypeClassMap(defs) {\r\n    return defs.reduce((result, sub) => {\r\n        result[sub.name] = sub.type;\r\n        return result;\r\n    }, {});\r\n}\r\n// create an array of type string constructors from the input\r\nexport function getTypeClassArray(defs) {\r\n    return defs.map(({ type }) => type);\r\n}\r\n// Returns the type Class for construction\r\nexport function getTypeClass(value) {\r\n    const Type = getTypeRegistry().get(value.type);\r\n    if (Type) {\r\n        return Type;\r\n    }\r\n    switch (value.info) {\r\n        case TypeDefInfo.Compact:\r\n            assert(value.sub && !Array.isArray(value.sub), 'Expected subtype for Compact');\r\n            return Compact.with(value.sub.type);\r\n        case TypeDefInfo.Enum:\r\n            assert(value.sub && Array.isArray(value.sub), 'Expected subtype for Enum');\r\n            return Enum.with(getTypeClassMap(value.sub));\r\n        case TypeDefInfo.Option:\r\n            assert(value.sub && !Array.isArray(value.sub), 'Expected subtype for Option');\r\n            return Option.with(value.sub.type);\r\n        case TypeDefInfo.Set:\r\n            assert(Array.isArray(value.sub), 'Expected nested info for Set');\r\n            return CodecSet.with(value.sub.reduce((result, { name, index }) => {\r\n                result[name] = index;\r\n                return result;\r\n            }, {}));\r\n        case TypeDefInfo.Struct:\r\n            assert(Array.isArray(value.sub), 'Expected nested subtypes for Struct');\r\n            return Struct.with(getTypeClassMap(value.sub));\r\n        case TypeDefInfo.Tuple:\r\n            assert(Array.isArray(value.sub), 'Expected nested subtypes for Tuple');\r\n            return Tuple.with(getTypeClassArray(value.sub));\r\n        case TypeDefInfo.Vec:\r\n            assert(value.sub && !Array.isArray(value.sub), 'Expected subtype for Vec');\r\n            const vsub = value.sub;\r\n            return (vsub.type === 'u8'\r\n                ? ClassOf('Bytes')\r\n                : Vec.with(vsub.type));\r\n        case TypeDefInfo.VecFixed:\r\n            assert(value.ext, 'Expected length & type information for fixed vector');\r\n            const ext = value.ext;\r\n            return (ext.type === 'u8'\r\n                ? U8aFixed.with((ext.length * 8))\r\n                : VecFixed.with(ext.type, ext.length));\r\n        case TypeDefInfo.Linkage:\r\n            assert(value.sub && !Array.isArray(value.sub), 'Expected subtype for Linkage');\r\n            return Linkage.withKey(value.sub.type);\r\n        case TypeDefInfo.DoubleMap:\r\n            assert(value.sub && !Array.isArray(value.sub), 'Expected subtype for DoubleMap');\r\n            return getTypeClass(value.sub);\r\n        case TypeDefInfo.Null:\r\n            return ClassOf('Null');\r\n    }\r\n    throw new Error(`Unable to determine type from ${JSON.stringify(value)}`);\r\n}\r\n// Initializes a type with a value. This also checks for fallbacks and in the cases\r\n// where isPedantic is specified (storage decoding), also check the format/structure\r\nfunction initType(Type, params = [], isPedantic) {\r\n    const created = new Type(...params);\r\n    const [value] = params;\r\n    // With isPedantic, actually check that the encoding matches that supplied. This\r\n    // is much slower, but verifies that we have the correct types defined\r\n    if (isPedantic && value && value.toU8a && !value.isEmpty) {\r\n        const inHex = value.toHex(true);\r\n        const crHex = created.toHex(true);\r\n        const hasMatch = inHex === crHex || (created instanceof Uint8Array\r\n            // strip the input length\r\n            ? (value.toU8a(true).toString() === created.toU8a().toString())\r\n            // compare raw. without additions\r\n            : (value.toU8a(true).toString() === created.toU8a(true).toString()));\r\n        if (!hasMatch) {\r\n            console.warn(`${created.toRawType()}:: Input doesn't match output, received ${inHex}, created ${crHex}`);\r\n        }\r\n    }\r\n    return created;\r\n}\r\n// An unsafe version of the `createType` below. It's unsafe because the `type`\r\n// argument here can be any string, which, if not parseable, will yield a\r\n// runtime error.\r\nexport function createTypeUnsafe(type, params = [], isPedantic) {\r\n    try {\r\n        return initType(createClass(type), params, isPedantic);\r\n    }\r\n    catch (error) {\r\n        throw new Error(`createType(${type}):: ${error.message}`);\r\n    }\r\n}\r\n/**\r\n * Create an instance of a `type` with a given `value`.\r\n * @param type - A recognizable string representing the type to create an\r\n * instance from\r\n * @param value - The value to instantiate the type with\r\n * @param isPedantic - Double-check that the input's encoding matches the\r\n * output's one. Slower, but ensures that we have a 100% grasp on the actual\r\n * provided value\r\n */\r\nexport default function createType(type, ...params) {\r\n    return createTypeUnsafe(type, params);\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/interfaceRegistry.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Compact.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Enum.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Linkage.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Option.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Set.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Struct.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Tuple.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/U8aFixed.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Vec.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/VecFixed.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/typeRegistry.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/codec/createType.d.ts","writeByteOrderMark":false,"text":"import { Codec, Constructor, InterfaceTypes } from '../types';\r\nimport { TypeDef } from './types';\r\nimport { InterfaceRegistry } from '../interfaceRegistry';\r\ndeclare type FromReg<T extends Codec, K extends string> = K extends InterfaceTypes ? InterfaceRegistry[K] : T;\r\nexport declare function typeSplit(type: string): string[];\r\nexport declare function getTypeDef(_type: string, name?: string): TypeDef;\r\nexport declare function createClass<T extends Codec = Codec, K extends string = string>(type: K): Constructor<FromReg<T, K>>;\r\nexport declare function ClassOfUnsafe<T extends Codec = Codec, K extends string = string>(name: K): Constructor<FromReg<T, K>>;\r\nexport declare function ClassOf<K extends InterfaceTypes>(name: K): Constructor<InterfaceRegistry[K]>;\r\nexport declare function getTypeClassMap(defs: TypeDef[]): Record<string, InterfaceTypes>;\r\nexport declare function getTypeClassArray(defs: TypeDef[]): (InterfaceTypes)[];\r\nexport declare function getTypeClass<T extends Codec = Codec>(value: TypeDef): Constructor<T>;\r\nexport declare function createTypeUnsafe<T extends Codec = Codec, K extends string = string>(type: K, params?: any[], isPedantic?: boolean): FromReg<T, K>;\r\n/**\r\n * Create an instance of a `type` with a given `value`.\r\n * @param type - A recognizable string representing the type to create an\r\n * instance from\r\n * @param value - The value to instantiate the type with\r\n * @param isPedantic - Double-check that the input's encoding matches the\r\n * output's one. Slower, but ensures that we have a 100% grasp on the actual\r\n * provided value\r\n */\r\nexport default function createType<K extends InterfaceTypes>(type: K, ...params: any[]): InterfaceRegistry[K];\r\nexport {};\r\n"}}
