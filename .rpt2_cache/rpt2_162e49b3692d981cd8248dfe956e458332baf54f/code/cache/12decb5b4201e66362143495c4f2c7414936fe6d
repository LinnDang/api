{"code":"// Copyright 2017-2019 @polkadot/api authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { EMPTY } from 'rxjs';\r\nimport { catchError, first, tap } from 'rxjs/operators';\r\nimport { isFunction, assert } from '@polkadot/util';\r\nimport ApiBase from '../Base';\r\nimport Combinator from './Combinator';\r\n/**\r\n * # @polkadot/api/promise\r\n *\r\n * ## Overview\r\n *\r\n * @name ApiPromise\r\n *\r\n * @description\r\n * ApiPromise is a standard JavaScript wrapper around the RPC and interfaces on the Polkadot network. As a full Promise-based, all interface calls return Promises, including the static `.create(...)`. Subscription calls utilise `(value) => {}` callbacks to pass through the latest values.\r\n *\r\n * The API is well suited to real-time applications where either the single-shot state is needed or use is to be made of the subscription-based features of Polkadot (and Substrate) clients.\r\n *\r\n * @see [[ApiRx]]\r\n *\r\n * ## Usage\r\n *\r\n * Making rpc calls -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import ApiPromise from '@polkadot/api/promise';\r\n *\r\n * // initialise via static create\r\n * const api = await ApiPromise.create();\r\n *\r\n * // make a subscription to the network head\r\n * api.rpc.chain.subscribeNewHead((header) => {\r\n *   console.log(`Chain is at #${header.number}`);\r\n * });\r\n * ```\r\n * <BR>\r\n *\r\n * Subscribing to chain state -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import { ApiPromise, WsProvider } from '@polkadot/api';\r\n *\r\n * // initialise a provider with a specific endpoint\r\n * const provider = new WsProvider('wss://example.com:9944')\r\n *\r\n * // initialise via isReady & new with specific provider\r\n * const api = await new ApiPromise({ provider }).isReady;\r\n *\r\n * // retrieve the block target time\r\n * const blockPeriod = await api.query.timestamp.blockPeriod().toNumber();\r\n * let last = 0;\r\n *\r\n * // subscribe to the current block timestamp, updates automatically (callback provided)\r\n * api.query.timestamp.now((timestamp) => {\r\n *   const elapsed = last\r\n *     ? `, ${timestamp.toNumber() - last}s since last`\r\n *     : '';\r\n *\r\n *   last = timestamp.toNumber();\r\n *   console.log(`timestamp ${timestamp}${elapsed} (${blockPeriod}s target)`);\r\n * });\r\n * ```\r\n * <BR>\r\n *\r\n * Submitting a transaction -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import ApiPromise from '@polkadot/api/promise';\r\n *\r\n * ApiPromise.create().then((api) => {\r\n *   const nonce = await api.query.system.accountNonce(keyring.alice.address);\r\n *\r\n *   api.tx.balances\r\n *     // create transfer\r\n *     transfer(keyring.bob.address, 12345)\r\n *     // sign the transcation\r\n *     .sign(keyring.alice, { nonce })\r\n *     // send the transaction (optional status callback)\r\n *     .send((status) => {\r\n *       console.log(`current status ${status.type}`);\r\n *     })\r\n *     // retrieve the submitted extrinsic hash\r\n *     .then((hash) => {\r\n *       console.log(`submitted with hash ${hash}`);\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport default class ApiPromise extends ApiBase {\r\n    /**\r\n     * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.\r\n     *\r\n     * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a\r\n     * provider (see the constructor arguments)\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import Api from '@polkadot/api/promise';\r\n     *\r\n     * Api.create().then(async (api) => {\r\n     *   const timestamp = await api.query.timestamp.now();\r\n     *\r\n     *   console.log(`lastest block timestamp ${timestamp}`);\r\n     * });\r\n     * ```\r\n     */\r\n    static create(options) {\r\n        return new ApiPromise(options).isReady;\r\n    }\r\n    /**\r\n     * @description Creates an instance of the ApiPromise class\r\n     *\r\n     * @param options Options to create an instance. This can be either [[ApiOptions]] or\r\n     * an [[WsProvider]].\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import Api from '@polkadot/api/promise';\r\n     *\r\n     * new Api().isReady.then((api) => {\r\n     *   api.rpc.subscribeNewHead((header) => {\r\n     *     console.log(`new block #${header.number.toNumber()}`);\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    constructor(options) {\r\n        super(options, 'promise');\r\n        this._isReadyPromise = new Promise((resolve) => {\r\n            super.once('ready', () => {\r\n                resolve(this);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @description Promise that returns the first time we are connected and loaded\r\n     */\r\n    get isReady() {\r\n        return this._isReadyPromise;\r\n    }\r\n    /**\r\n     * @description Returns a clone of this ApiPromise instance (new underlying provider connection)\r\n     */\r\n    clone() {\r\n        return new ApiPromise({\r\n            ...this._options,\r\n            source: this\r\n        });\r\n    }\r\n    /**\r\n     * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions\r\n     * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`\r\n     * @param callback A callback that will return an Array of all the values this combinator has been applied to\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';\r\n     *\r\n     * // combines values from balance & nonce as it updates\r\n     * api.combineLatest([\r\n     *   api.rpc.chain.subscribeNewHead,\r\n     *   [api.query.balances.freeBalance, address],\r\n     *   (cb) => api.query.system.accountNonce(address, cb)\r\n     * ], ([head, balance, nonce]) => {\r\n     *   console.log(`#${head.number}: You have ${balance} units, with ${nonce} transactions sent`);\r\n     * });\r\n     * ```\r\n     */\r\n    async combineLatest(fns, callback) {\r\n        const combinator = new Combinator(fns, callback);\r\n        return () => {\r\n            combinator.unsubscribe();\r\n        };\r\n    }\r\n    decorateMethod(method, options) {\r\n        const needsCallback = options && options.methodName && options.methodName.includes('subscribe');\r\n        return function (...args) {\r\n            let callback;\r\n            const actualArgs = args.slice();\r\n            // If the last arg is a function, we pop it, put it into callback.\r\n            // actualArgs will then hold the actual arguments to be passed to `method`\r\n            if (args.length && isFunction(args[args.length - 1])) {\r\n                callback = actualArgs.pop();\r\n            }\r\n            // When we need a subscription, ensure that a valid callback is actually passed\r\n            assert(!needsCallback || isFunction(callback), 'Expected a callback to be passed with subscriptions');\r\n            if (!callback) {\r\n                return method(...actualArgs).pipe(first()).toPromise();\r\n            }\r\n            return new Promise((resolve, reject) => {\r\n                let isCompleted = false;\r\n                const subscription = method(...actualArgs)\r\n                    .pipe(\r\n                // if we find an error (invalid params, etc), reject the promise\r\n                catchError((error) => {\r\n                    if (!isCompleted) {\r\n                        isCompleted = true;\r\n                        reject(error);\r\n                    }\r\n                    // we don't want to continue, so empty observable it is\r\n                    return EMPTY;\r\n                }), \r\n                // upon the first result, resolve the with the unsub function\r\n                tap(() => {\r\n                    if (!isCompleted) {\r\n                        isCompleted = true;\r\n                        resolve(() => subscription.unsubscribe());\r\n                    }\r\n                }))\r\n                    .subscribe(callback);\r\n            });\r\n        };\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/rxjs/operators/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/Base.ts","/Users/jacogreeff/Projects/polkadot/api/packages/api/src/promise/Combinator.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/api/src/promise/Api.d.ts","writeByteOrderMark":false,"text":"import { AnyFunction } from '@polkadot/types/types';\r\nimport { ApiOptions, DecorateMethodOptions, StorageEntryPromiseOverloads, UnsubscribePromise } from '../types';\r\nimport ApiBase from '../Base';\r\nimport { CombinatorCallback, CombinatorFunction } from './Combinator';\r\n/**\r\n * # @polkadot/api/promise\r\n *\r\n * ## Overview\r\n *\r\n * @name ApiPromise\r\n *\r\n * @description\r\n * ApiPromise is a standard JavaScript wrapper around the RPC and interfaces on the Polkadot network. As a full Promise-based, all interface calls return Promises, including the static `.create(...)`. Subscription calls utilise `(value) => {}` callbacks to pass through the latest values.\r\n *\r\n * The API is well suited to real-time applications where either the single-shot state is needed or use is to be made of the subscription-based features of Polkadot (and Substrate) clients.\r\n *\r\n * @see [[ApiRx]]\r\n *\r\n * ## Usage\r\n *\r\n * Making rpc calls -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import ApiPromise from '@polkadot/api/promise';\r\n *\r\n * // initialise via static create\r\n * const api = await ApiPromise.create();\r\n *\r\n * // make a subscription to the network head\r\n * api.rpc.chain.subscribeNewHead((header) => {\r\n *   console.log(`Chain is at #${header.number}`);\r\n * });\r\n * ```\r\n * <BR>\r\n *\r\n * Subscribing to chain state -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import { ApiPromise, WsProvider } from '@polkadot/api';\r\n *\r\n * // initialise a provider with a specific endpoint\r\n * const provider = new WsProvider('wss://example.com:9944')\r\n *\r\n * // initialise via isReady & new with specific provider\r\n * const api = await new ApiPromise({ provider }).isReady;\r\n *\r\n * // retrieve the block target time\r\n * const blockPeriod = await api.query.timestamp.blockPeriod().toNumber();\r\n * let last = 0;\r\n *\r\n * // subscribe to the current block timestamp, updates automatically (callback provided)\r\n * api.query.timestamp.now((timestamp) => {\r\n *   const elapsed = last\r\n *     ? `, ${timestamp.toNumber() - last}s since last`\r\n *     : '';\r\n *\r\n *   last = timestamp.toNumber();\r\n *   console.log(`timestamp ${timestamp}${elapsed} (${blockPeriod}s target)`);\r\n * });\r\n * ```\r\n * <BR>\r\n *\r\n * Submitting a transaction -\r\n * <BR>\r\n *\r\n * ```javascript\r\n * import ApiPromise from '@polkadot/api/promise';\r\n *\r\n * ApiPromise.create().then((api) => {\r\n *   const nonce = await api.query.system.accountNonce(keyring.alice.address);\r\n *\r\n *   api.tx.balances\r\n *     // create transfer\r\n *     transfer(keyring.bob.address, 12345)\r\n *     // sign the transcation\r\n *     .sign(keyring.alice, { nonce })\r\n *     // send the transaction (optional status callback)\r\n *     .send((status) => {\r\n *       console.log(`current status ${status.type}`);\r\n *     })\r\n *     // retrieve the submitted extrinsic hash\r\n *     .then((hash) => {\r\n *       console.log(`submitted with hash ${hash}`);\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport default class ApiPromise extends ApiBase<'promise'> {\r\n    private _isReadyPromise;\r\n    /**\r\n     * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.\r\n     *\r\n     * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a\r\n     * provider (see the constructor arguments)\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import Api from '@polkadot/api/promise';\r\n     *\r\n     * Api.create().then(async (api) => {\r\n     *   const timestamp = await api.query.timestamp.now();\r\n     *\r\n     *   console.log(`lastest block timestamp ${timestamp}`);\r\n     * });\r\n     * ```\r\n     */\r\n    static create(options?: ApiOptions): Promise<ApiPromise>;\r\n    /**\r\n     * @description Creates an instance of the ApiPromise class\r\n     *\r\n     * @param options Options to create an instance. This can be either [[ApiOptions]] or\r\n     * an [[WsProvider]].\r\n     *\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * import Api from '@polkadot/api/promise';\r\n     *\r\n     * new Api().isReady.then((api) => {\r\n     *   api.rpc.subscribeNewHead((header) => {\r\n     *     console.log(`new block #${header.number.toNumber()}`);\r\n     *   });\r\n     * });\r\n     * ```\r\n     */\r\n    constructor(options?: ApiOptions);\r\n    /**\r\n     * @description Promise that returns the first time we are connected and loaded\r\n     */\r\n    readonly isReady: Promise<ApiPromise>;\r\n    /**\r\n     * @description Returns a clone of this ApiPromise instance (new underlying provider connection)\r\n     */\r\n    clone(): ApiPromise;\r\n    /**\r\n     * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions\r\n     * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`\r\n     * @param callback A callback that will return an Array of all the values this combinator has been applied to\r\n     * @example\r\n     * <BR>\r\n     *\r\n     * ```javascript\r\n     * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';\r\n     *\r\n     * // combines values from balance & nonce as it updates\r\n     * api.combineLatest([\r\n     *   api.rpc.chain.subscribeNewHead,\r\n     *   [api.query.balances.freeBalance, address],\r\n     *   (cb) => api.query.system.accountNonce(address, cb)\r\n     * ], ([head, balance, nonce]) => {\r\n     *   console.log(`#${head.number}: You have ${balance} units, with ${nonce} transactions sent`);\r\n     * });\r\n     * ```\r\n     */\r\n    combineLatest(fns: (CombinatorFunction | [CombinatorFunction, ...any[]])[], callback: CombinatorCallback): UnsubscribePromise;\r\n    protected decorateMethod<Method extends AnyFunction>(method: Method, options?: DecorateMethodOptions): StorageEntryPromiseOverloads;\r\n}\r\n"}}
