{"code":"// Copyright 2017-2019 @polkadot/api-metadata authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { assert, isHex, isObject, isU8a, hexToU8a } from '@polkadot/util';\r\nimport { getTypeDef, getTypeClass } from '../../codec/createType';\r\nimport Struct from '../../codec/Struct';\r\nimport U8aFixed from '../../codec/U8aFixed';\r\nconst FN_UNKNOWN = {\r\n    method: 'unknown',\r\n    section: 'unknown'\r\n};\r\nconst injected = {};\r\n/**\r\n * @name CallIndex\r\n * @description\r\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\r\n */\r\nexport class CallIndex extends U8aFixed {\r\n    constructor(value) {\r\n        super(value, 16);\r\n    }\r\n}\r\n/**\r\n * @name Call\r\n * @description\r\n * Extrinsic function descriptor, as defined in\r\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\r\n */\r\nexport default class Call extends Struct {\r\n    constructor(value, meta) {\r\n        const decoded = Call.decodeCall(value, meta);\r\n        super({\r\n            callIndex: CallIndex,\r\n            args: Struct.with(decoded.argsDef)\r\n        }, decoded);\r\n        this._meta = decoded.meta;\r\n    }\r\n    /**\r\n     * Decode input to pass into constructor.\r\n     *\r\n     * @param value - Value to decode, one of:\r\n     * - hex\r\n     * - Uint8Array\r\n     * - {@see DecodeMethodInput}\r\n     * @param _meta - Metadata to use, so that `injectMethods` lookup is not\r\n     * necessary.\r\n     */\r\n    static decodeCall(value = new Uint8Array(), _meta) {\r\n        if (isHex(value)) {\r\n            return Call.decodeCall(hexToU8a(value), _meta);\r\n        }\r\n        else if (isU8a(value)) {\r\n            // The first 2 bytes are the callIndex\r\n            const callIndex = value.subarray(0, 2);\r\n            // Find metadata with callIndex\r\n            const meta = _meta || Call.findFunction(callIndex).meta;\r\n            return {\r\n                args: value.subarray(2),\r\n                argsDef: Call.getArgsDef(meta),\r\n                callIndex,\r\n                meta\r\n            };\r\n        }\r\n        else if (isObject(value) && value.callIndex && value.args) {\r\n            // destructure value, we only pass args/methodsIndex out\r\n            const { args, callIndex } = value;\r\n            // Get the correct lookupIndex\r\n            const lookupIndex = callIndex instanceof CallIndex\r\n                ? callIndex.toU8a()\r\n                : callIndex;\r\n            // Find metadata with callIndex\r\n            const meta = _meta || Call.findFunction(lookupIndex).meta;\r\n            return {\r\n                args,\r\n                argsDef: Call.getArgsDef(meta),\r\n                meta,\r\n                callIndex\r\n            };\r\n        }\r\n        throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\r\n    }\r\n    // If the extrinsic function has an argument of type `Origin`, we ignore it\r\n    static filterOrigin(meta) {\r\n        // FIXME should be `arg.type !== Origin`, but doesn't work...\r\n        return meta\r\n            ? meta.args.filter(({ type }) => type.toString() !== 'Origin')\r\n            : [];\r\n    }\r\n    // We could only inject the meta (see injectMethods below) and then do a\r\n    // meta-only lookup via\r\n    //\r\n    //   metadata.modules[callIndex[0]].module.call.functions[callIndex[1]]\r\n    //\r\n    // As a convenience helper though, we return the full constructor function,\r\n    // which includes the meta, name, section & actual interface for calling\r\n    static findFunction(callIndex) {\r\n        assert(Object.keys(injected).length > 0, 'Calling Call.findFunction before extrinsics have been injected.');\r\n        return injected[callIndex.toString()] || FN_UNKNOWN;\r\n    }\r\n    /**\r\n     * Get a mapping of `argument name -> argument type` for the function, from\r\n     * its metadata.\r\n     *\r\n     * @param meta - The function metadata used to get the definition.\r\n     */\r\n    static getArgsDef(meta) {\r\n        return Call.filterOrigin(meta).reduce((result, { name, type }) => {\r\n            const Type = getTypeClass(getTypeDef(type.toString()));\r\n            result[name.toString()] = Type;\r\n            return result;\r\n        }, {});\r\n    }\r\n    // This is called/injected by the API on init, allowing a snapshot of\r\n    // the available system extrinsics to be used in lookups\r\n    static injectMethods(moduleMethods) {\r\n        Object.values(moduleMethods).forEach((methods) => Object.values(methods).forEach((method) => {\r\n            injected[method.callIndex.toString()] = method;\r\n        }));\r\n    }\r\n    /**\r\n     * @description The arguments for the function call\r\n     */\r\n    get args() {\r\n        // FIXME This should return a Struct instead of an Array\r\n        return [...this.get('args').values()];\r\n    }\r\n    /**\r\n     * @description Thge argument defintions\r\n     */\r\n    get argsDef() {\r\n        return Call.getArgsDef(this.meta);\r\n    }\r\n    /**\r\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\r\n     */\r\n    get callIndex() {\r\n        return this.get('callIndex').toU8a();\r\n    }\r\n    /**\r\n     * @description The encoded data\r\n     */\r\n    get data() {\r\n        return this.get('args').toU8a();\r\n    }\r\n    /**\r\n     * @description `true` if the `Origin` type is on the method (extrinsic method)\r\n     */\r\n    get hasOrigin() {\r\n        const firstArg = this.meta.args[0];\r\n        return !!firstArg && firstArg.type.toString() === 'Origin';\r\n    }\r\n    /**\r\n     * @description The [[FunctionMetadata]]\r\n     */\r\n    get meta() {\r\n        return this._meta;\r\n    }\r\n    /**\r\n     * @description Returns the name of the method\r\n     */\r\n    get methodName() {\r\n        return Call.findFunction(this.callIndex).method;\r\n    }\r\n    /**\r\n     * @description Returns the module containing the method\r\n     */\r\n    get sectionName() {\r\n        return Call.findFunction(this.callIndex).section;\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return 'Call';\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/packages/types/src/types.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/createType.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Struct.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/U8aFixed.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/Metadata/v7/Calls.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Generic/Call.d.ts","writeByteOrderMark":false,"text":"import { AnyU8a, ArgsDef, CallFunction, Codec, IMethod, ModulesWithCalls } from '../../types';\r\nimport Struct from '../../codec/Struct';\r\nimport U8aFixed from '../../codec/U8aFixed';\r\nimport { FunctionMetadata as FunctionMetadataV7, FunctionArgumentMetadata } from '../../Metadata/v7/Calls';\r\n/**\r\n * @name CallIndex\r\n * @description\r\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\r\n */\r\nexport declare class CallIndex extends U8aFixed {\r\n    constructor(value?: AnyU8a);\r\n}\r\n/**\r\n * @name Call\r\n * @description\r\n * Extrinsic function descriptor, as defined in\r\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\r\n */\r\nexport default class Call extends Struct implements IMethod {\r\n    protected _meta: FunctionMetadataV7;\r\n    constructor(value: any, meta?: FunctionMetadataV7);\r\n    /**\r\n     * Decode input to pass into constructor.\r\n     *\r\n     * @param value - Value to decode, one of:\r\n     * - hex\r\n     * - Uint8Array\r\n     * - {@see DecodeMethodInput}\r\n     * @param _meta - Metadata to use, so that `injectMethods` lookup is not\r\n     * necessary.\r\n     */\r\n    private static decodeCall;\r\n    static filterOrigin(meta?: FunctionMetadataV7): FunctionArgumentMetadata[];\r\n    static findFunction(callIndex: Uint8Array): CallFunction;\r\n    /**\r\n     * Get a mapping of `argument name -> argument type` for the function, from\r\n     * its metadata.\r\n     *\r\n     * @param meta - The function metadata used to get the definition.\r\n     */\r\n    private static getArgsDef;\r\n    static injectMethods(moduleMethods: ModulesWithCalls): void;\r\n    /**\r\n     * @description The arguments for the function call\r\n     */\r\n    readonly args: Codec[];\r\n    /**\r\n     * @description Thge argument defintions\r\n     */\r\n    readonly argsDef: ArgsDef;\r\n    /**\r\n     * @description The encoded `[sectionIndex, methodIndex]` identifier\r\n     */\r\n    readonly callIndex: Uint8Array;\r\n    /**\r\n     * @description The encoded data\r\n     */\r\n    readonly data: Uint8Array;\r\n    /**\r\n     * @description `true` if the `Origin` type is on the method (extrinsic method)\r\n     */\r\n    readonly hasOrigin: boolean;\r\n    /**\r\n     * @description The [[FunctionMetadata]]\r\n     */\r\n    readonly meta: FunctionMetadataV7;\r\n    /**\r\n     * @description Returns the name of the method\r\n     */\r\n    readonly methodName: string;\r\n    /**\r\n     * @description Returns the module containing the method\r\n     */\r\n    readonly sectionName: string;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n}\r\n"}}
