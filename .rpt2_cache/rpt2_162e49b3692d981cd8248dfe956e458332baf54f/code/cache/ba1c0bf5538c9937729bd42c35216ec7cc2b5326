{"code":"// Copyright 2017-2019 @polkadot/types authors & contributors\r\n// This software may be modified and distributed under the terms\r\n// of the Apache-2.0 license. See the LICENSE file for details.\r\nimport { isBn, isHex, isNumber, isU8a, u8aConcat, u8aToHex, u8aToU8a, u8aToBn } from '@polkadot/util';\r\nimport { decodeAddress } from '@polkadot/util-crypto';\r\nimport createType from '../../codec/createType';\r\nimport Base from '../../codec/Base';\r\nimport AccountId from './AccountId';\r\nimport AccountIndex from './AccountIndex';\r\nexport const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\r\n/**\r\n * @name Address\r\n * @description\r\n * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.\r\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\r\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\r\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\r\n */\r\nexport default class Address extends Base {\r\n    constructor(value = new Uint8Array()) {\r\n        super(Address.decodeAddress(value));\r\n    }\r\n    static decodeAddress(value) {\r\n        if (value instanceof AccountId || value instanceof AccountIndex) {\r\n            return value;\r\n        }\r\n        else if (isBn(value) || isNumber(value)) {\r\n            return createType('AccountIndex', value);\r\n        }\r\n        else if (value instanceof Address) {\r\n            return value.raw;\r\n        }\r\n        else if (Array.isArray(value) || isHex(value) || isU8a(value)) {\r\n            return Address.decodeU8a(u8aToU8a(value));\r\n        }\r\n        const decoded = decodeAddress(value);\r\n        return decoded.length === 32\r\n            ? createType('AccountId', decoded)\r\n            : createType('AccountIndex', u8aToBn(decoded, true));\r\n    }\r\n    static decodeU8a(value) {\r\n        // This allows us to instantiate an address with a raw publicKey. Do this first before\r\n        // we checking the first byte, otherwise we may split an already-existent valid address\r\n        if (value.length === 32) {\r\n            return createType('AccountId', value);\r\n        }\r\n        else if (value[0] === 0xff) {\r\n            return createType('AccountId', value.subarray(1));\r\n        }\r\n        const [offset, length] = AccountIndex.readLength(value);\r\n        return createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));\r\n    }\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    get encodedLength() {\r\n        const rawLength = this.rawLength;\r\n        return rawLength + (\r\n        // for 1 byte AccountIndexes, we are not adding a specific prefix\r\n        rawLength > 1\r\n            ? 1\r\n            : 0);\r\n    }\r\n    /**\r\n     * @description The length of the raw value, either AccountIndex or AccountId\r\n     */\r\n    get rawLength() {\r\n        return this.raw instanceof AccountIndex\r\n            ? AccountIndex.calcLength(this.raw)\r\n            : this.raw.encodedLength;\r\n    }\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex() {\r\n        return u8aToHex(this.toU8a());\r\n    }\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType() {\r\n        return 'Address';\r\n    }\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare) {\r\n        const encoded = this.raw.toU8a().subarray(0, this.rawLength);\r\n        return isBare\r\n            ? encoded\r\n            : u8aConcat(this.raw instanceof AccountIndex\r\n                ? AccountIndex.writeLength(encoded)\r\n                : ACCOUNT_ID_PREFIX, encoded);\r\n    }\r\n}\r\n","references":["/Users/jacogreeff/Projects/polkadot/api/node_modules/@types/bn.js/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/node_modules/@polkadot/util-crypto/index.d.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/createType.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/codec/Base.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Generic/AccountId.ts","/Users/jacogreeff/Projects/polkadot/api/packages/types/src/primitive/Generic/AccountIndex.ts"],"dts":{"name":"/Users/jacogreeff/Projects/polkadot/api/types/src/primitive/Generic/Address.d.ts","writeByteOrderMark":false,"text":"import BN from 'bn.js';\r\nimport Base from '../../codec/Base';\r\nimport AccountId from './AccountId';\r\nimport AccountIndex from './AccountIndex';\r\ndeclare type AnyAddress = BN | Address | AccountId | AccountIndex | number[] | Uint8Array | number | string;\r\nexport declare const ACCOUNT_ID_PREFIX: Uint8Array;\r\n/**\r\n * @name Address\r\n * @description\r\n * A wrapper around an AccountId and/or AccountIndex that is encoded with a prefix.\r\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\r\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\r\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\r\n */\r\nexport default class Address extends Base<AccountId | AccountIndex> {\r\n    constructor(value?: AnyAddress);\r\n    static decodeAddress(value: AnyAddress): AccountId | AccountIndex;\r\n    private static decodeU8a;\r\n    /**\r\n     * @description The length of the value when encoded as a Uint8Array\r\n     */\r\n    readonly encodedLength: number;\r\n    /**\r\n     * @description The length of the raw value, either AccountIndex or AccountId\r\n     */\r\n    readonly rawLength: number;\r\n    /**\r\n     * @description Returns a hex string representation of the value\r\n     */\r\n    toHex(): string;\r\n    /**\r\n     * @description Returns the base runtime type name for this instance\r\n     */\r\n    toRawType(): string;\r\n    /**\r\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\r\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\r\n     */\r\n    toU8a(isBare?: boolean): Uint8Array;\r\n}\r\nexport {};\r\n"}}
